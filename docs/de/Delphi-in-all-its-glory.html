<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Delphi in all its glory</title>
<link rel="stylesheet" href="../styles.css">
<meta property="og:url" content="https://delphi-books.com/de/Delphi-in-all-its-glory.html">
<link rel="canonical" href="https://delphi-books.com/de/Delphi-in-all-its-glory.html">
<meta property="og:title" content="Delphi in all its glory">
<meta property="og:type" content="book">
<meta property="og:site_name" content="Delphi books">
<meta property="og:image" content="https://delphi-books.com/covers/500x0/Delphi-in-all-its-glory.jpg">
<meta property="og:image:secure_url"  content="https://delphi-books.com/covers/500x0/Delphi-in-all-its-glory.jpg">
<meta property="book:author" content="Gabriel Moraru">
<meta property="book:isbn" content="9798387412141">
<meta property="book:release_date" content="2023-03-29">

<meta name="twitter:card" content="photo">
<meta name="twitter:image" content="https://delphi-books.com/covers/500x0/Delphi-in-all-its-glory.jpg">
<link rel="image_src" href="https://delphi-books.com/covers/130x110/Delphi-in-all-its-glory.jpg">
<link rel="alternate" type="application/rss+xml" title="List of Delphi books" href="https://delphi-books.com/de/rss.xml">
</head>
<body>
<div id="container">
<header>
<a href="index.html" title="Delphi-Books.com" class="logo"><img src="../img/Delphi-Books-278x150.gif" alt="Delphi Books logo"></a>
<span class="btngroup">
<a href="livres.html" title="All Delphi books" class="btn"><img src="../img/btn/BoutonLivres.gif" alt="Books"></a>
<a href="auteurs.html" title="All writers" class="btn"><img src="../img/btn/BoutonAuteurs.gif" alt="Writers"></a>
<a href="editeurs.html" title="All publishers" class="btn"><img src="../img/btn/BoutonEditeurs.gif" alt="Publishers"></a>
<a href="langues.html" title="All languages" class="btn"><img src="../img/btn/BoutonLangues.gif" alt="Languages"></a>
</span>
</header>
<div id="content" itemscope itemtype="http://schema.org/Book">
<p class="coverimg"><img src="../covers/500x0/Delphi-in-all-its-glory.jpg" title="Delphi in all its glory" itemprop="image"></p>
<h1>Delphi in all its glory</h1>

<p>Writed by : <a href="Gabriel-Moraru.html"><span itemprop="name">Gabriel Moraru</span></a></p>
<p>Published date : 29/03/2023<meta itemprop="datePublished" content="2023-03-29"></p>

<p>ISBN-13 : <span itemprop="isbn">9798387412141</span></p>
<p>Language : <span lang="en"><a href="English.html"><img src="../img/flag/en.gif" alt="English" class="lngtxt"></a> <a href="English.html"><span itemprop="inLanguage">English</span></a></span></p>
<p>Web site : <a href="https://gabrielmoraru.com/delphi-in-all-its-glory/">https://gabrielmoraru.com/delphi-in-all-its-glory/</a></p>

<a name="about"></a><h2>About Delphi in all its glory</h2><div lang="en"><p>For whom is this book for?</p>
<p>This book is for everyone who wants to learn how to build fast, good-looking, stable applications. It doesn't matter if you never wrote a line of code, we will start from ground zero, but we will not stop until we reach the most advanced topics.</p>
<p>What is Delphi?</p>
<p>Delphi is a modern multi-purpose programming language. With Delphi, we can create cool looking graphic applications for Windows, Mac, Linux and Android. Take a look at "Let there be styles" chapter to see Delphi programs in all their beauty.</p>
<p>Delphi is fast, Delphi is easy to learn (seriously), Delphi is free (for personal use with its Community Edition).</p></div>
<a name="shopping"><h2>Where to buy ?</h2>
<p>This book has the ISBN13 "9798387412141".<br />
If it is still available for sale, you can order it in your favorite bookstore, by its publisher or online at 
<a href="https://www.amazon.ca/gp/search?ie=UTF8&tag=delphibooks0c-20&linkCode=ur2&linkId=06449c565b5e94cd52a31aa716bc1ba8&camp=15121&creative=330641&index=books-ca&keywords=9798387412141">Amazon CA</a>, 
<a href="https://www.amazon.fr/gp/search?ie=UTF8&tag=delphibooks-21&linkCode=ur2&linkId=f84e214ca52c39bce185829b8a3e7abb&camp=1642&creative=6746&index=books&keywords=9798387412141">Amazon FR</a>, 
<a href="https://www.amazon.co.jp/gp/search?ie=UTF8&tag=delphibooks-22&linkCode=ur2&linkId=13509b4b9c8ab380d4d355dc542b00e9&camp=247&creative=1211&index=english-books&keywords=9798387412141">Amazon JP</a>, 
<a href="https://www.amazon.co.uk/gp/search?ie=UTF8&tag=delphibooks0c-21&linkCode=ur2&linkId=c3323f708d3cefef559e46a18f5bd7da&camp=1634&creative=6738&index=books&keywords=9798387412141">Amazon UK</a> or 
<a href="https://www.amazon.com/gp/search?ie=UTF8&tag=delphibooks0b-20&linkCode=ur2&linkId=b9687477288435c2b485456516789778&camp=1789&creative=9325&index=books&keywords=9798387412141">Amazon USA</a> depending on your country.</p>
<a name="toc"></a><h2>Table of content</h2><div lang="en"><p>1. Overview . . . . . 2</p>
<ul>
<li>For whom is this book for? . . . . . 2</li>
<li>What is Delphi? . . . . . 2</li>
<li>What will you learn from this book? . . . . . 2</li>
<li>Book layout . . . . . 3</li>
<li>Who am I? . . . . . 3</li>
<li>How is this book written? . . . . . 4</li>
<li>This book is eco-friendly . . . . . 4</li>
<li>Pre-requisites for this book . . . . . 4</li>
<li>Let’s start . . . . . 4</li></ul>
<p>2. Table of content . . . . . 5</p>
<p>3. What is Delphi? . . . . . 24</p>
<ul>
<li>Delphi is RAD . . . . . 24</li>
<li>Delphi is general-purpose . . . . . 24</li>
<li>Delphi has deep roots . . . . . 24</li>
<li>A bit of history . . . . . 25</li>
<li>Delphi = GUI . . . . . 26</li>
<li>What is the VCL? . . . . . 26</li>
<li>What is RAD Studio? . . . . . 26</li>
<li>An IDE with multiple personalities. How does it work? . . . . . 27</li>
<li>A complete IDE . . . . . 28</li>
<li>Mature and polished . . . . . 28</li>
<li>But, it must be expensive... right? . . . . . 29</li>
<li>What can we build right out of the box, with Delphi? . . . . . 30</li>
<li>Advantages of Delphi applications . . . . . 32</li>
<li>Where can we use Delphi? . . . . . 34</li>
<li>Where can’t we use Delphi? . . . . . 35</li>
<li>Delphi’s productivity . . . . . 35</li>
<li>Famous programs built with Delphi . . . . . 36</li>
<li>Summary . . . . . 36</li></ul>
<p>4. Delphi today . . . . . 37</p>
<ul>
<li>Popularity . . . . . 37</li>
<li>About Evil, Darth Vader and... Bill Gates . . . . . 38</li>
<li>Availability of libraries . . . . . 39</li>
<li>A brighter future . . . . . 39</li>
<li>Tiobe Index . . . . . 40</li>
<li>Summary . . . . . 40</li></ul>
<p>5. An overview of the Delphi language . . . . . 42</p>
<ul>
<li>Clarity . . . . . 42</li>
<li>A strongly typed language . . . . . 42</li>
<li>Well designed . . . . . 42</li>
<li>One string to rule them all . . . . . 43</li>
<li>Not open-source . . . . . 43</li>
<li>Fastest compiler . . . . . 45</li>
<li>Better error messages . . . . . 45</li>
<li>The compiler is here to help us . . . . . 46</li>
<li>No more pointers . . . . . 46</li>
<li>ASM in the mix . . . . . 46</li>
<li>Damn fast . . . . . 46</li>
<li>Compared to Julia . . . . . 47</li>
<li>What kind of applications can we build with Delphi? . . . . . 47</li>
<li>Why building apps is so easy with Delphi? . . . . . 48</li>
<li>Delphi is WYSIWYG . . . . . 48</li>
<li>Quick mockups . . . . . 48</li>
<li>The VCL framework . . . . . 49</li>
<li>Low code / no code . . . . . 49</li>
<li>Portable code . . . . . 50</li>
<li>Native look . . . . . 50</li>
<li>Ready for the future . . . . . 50</li>
<li>The never-ending story . . . . . 51</li>
<li>Reminder . . . . . 51</li></ul>
<p>6. Delphi’s brothers . . . . . 52</p>
<ul>
<li>Lazarus / FPC . . . . . 52</li>
<li>The “Burning Monkey” . . . . . 54</li>
<li>A bit of history . . . . . 54</li>
<li>Firemoneky = VCL on steroids . . . . . 55</li>
<li>Disadvantages of FMX . . . . . 55</li>
<li>Converting a VCL project to FireMonkey . . . . . 56</li>
<li>Delphi’s cousin . . . . . 57</li>
<li>Summary . . . . . 57</li></ul>
<p>7. Installing Delphi . . . . . 58</p>
<ul>
<li>ISO installer . . . . . 58</li>
<li>The installation folder . . . . . 58</li>
<li>Delphi sample projects . . . . . 62</li>
<li>Delphi version info . . . . . 62</li>
<li>Known bugs . . . . . 62</li>
<li>Updates . . . . . 62</li>
<li>We are done . . . . . 63</li></ul>
<p>8. Let’s get started . . . . . 64</p>
<ul>
<li>Anatomy of a Delphi Project . . . . . 64</li>
<li>The Project Manager . . . . . 64</li>
<li>Project Options . . . . . 66</li>
<li>The DProj: DPR’s little brother . . . . . 71</li>
<li>Anatomy of a Delphi unit . . . . . 72</li></ul>
<p>9. IDE this... IDE that... . . . . . 76</p>
<ul>
<li>The main menu . . . . . 77</li>
<li>File . . . . . 77</li>
<li>Edit . . . . . 77</li>
<li>Search . . . . . 77</li>
<li>Refactor . . . . . 78</li>
<li>Run . . . . . 78</li>
<li>GExperts and CnPack . . . . . 78</li>
<li>Project . . . . . 78</li>
<li>The main components of the IDE . . . . . 80</li>
<li>The Project Manager . . . . . 80</li>
<li>The Component Palette . . . . . 80</li>
<li>The Object Inspector . . . . . 80</li>
<li>The Messages window . . . . . 80</li>
<li>Form designer . . . . . 80</li>
<li>Customizing the IDE . . . . . 81</li>
<li>The Code Editor . . . . . 82</li>
<li>Code insights [1] . . . . . 82</li>
<li>Code insights [2] . . . . . 82</li>
<li>Indent a block of code . . . . . 83</li>
<li>Easily re-order lines code . . . . . 83</li>
<li>Auto-fix typos . . . . . 83</li>
<li>Code Editor useful keyboard shortcuts . . . . . 83</li>
<li>The Form Designer . . . . . 84</li>
<li>Common IDE shortcuts . . . . . 85</li>
<li>Third party IDE plugins for Delphi . . . . . 86</li>
<li>DDevExtensions . . . . . 86</li>
<li>CnPack . . . . . 87</li>
<li>GExperts . . . . . 91</li>
<li>We can build our own plugins . . . . . 91</li>
<li>Plugin management . . . . . 92</li></ul>
<p>10. Our first Delphi application . . . . . 93</p>
<ul>
<li>Smallest Delphi application . . . . . 93</li>
<li>Let’s start . . . . . 93</li>
<li>Form = PAS + DFM . . . . . 98</li></ul>
<p>11. A crash course in the Delphi language . . . . . 99</p>
<ul>
<li>If you already know C++ . . . . . 99</li>
<li>A typical Delphi piece of code . . . . . 100</li>
<li>Comments . . . . . 101</li>
<li>Variables . . . . . 101</li>
<li>What is a variable? . . . . . 101</li>
<li>What are data types? . . . . . 101</li>
<li>Declaring variables . . . . . 102</li>
<li>General naming conventions in Delphi . . . . . 103</li>
<li>Naming variables . . . . . 104</li>
<li>Global versus local variables . . . . . 105</li>
<li>Variable initialization . . . . . 106</li>
<li>Assigning values to a variable . . . . . 107</li>
<li>Constants . . . . . 108</li>
<li>Arithmetic operators . . . . . 109</li>
<li>How do computers store numbers in their memory? . . . . . 110</li>
<li>Memory Cells . . . . . 110</li>
<li>Data types . . . . . 113</li>
<li>Primitive Data Types . . . . . 114</li>
<li>Managed Data Types . . . . . 115</li>
<li>Delphi is “strong typed” . . . . . 116</li>
<li>Boolean data type . . . . . 117</li>
<li>Integer data type . . . . . 117</li>
<li>Strings . . . . . 119</li>
<li>Advanced topics . . . . . 125</li>
<li>Enumerations . . . . . 126</li>
<li>Subranges . . . . . 127</li>
<li>Real numbers . . . . . 127</li>
<li>Arrays . . . . . 130</li>
<li>The size of a variable . . . . . 137</li>
<li>Defining our own data types . . . . . 139</li>
<li>Routines . . . . . 140</li>
<li>1. Compartmentalizing your code . . . . . 140</li>
<li>2. Reusing your code . . . . . 141</li>
<li>Procedures . . . . . 142</li>
<li>Functions . . . . . 143</li>
<li>Good practice . . . . . 149</li>
<li>Statement separator . . . . . 149</li>
<li>How does a computer program work? . . . . . 150</li>
<li>Displaying a message . . . . . 150</li>
<li>Records . . . . . 151</li>
<li>Assigning records . . . . . 152</li>
<li>Field initialization . . . . . 155</li>
<li>Advanced topics . . . . . 155</li>
<li>With . . . . . 156</li>
<li>FOR loops . . . . . 157</li>
<li>While . . . . . 159</li>
<li>Repeat/Until . . . . . 160</li>
<li>Nested routines . . . . . 160</li>
<li>Function overloading . . . . . 161</li>
<li>Parameters of a routine . . . . . 161</li>
<li>Open array parameters . . . . . 163</li>
<li>Not all parameters are created equal . . . . . 164</li>
<li>By reference . . . . . 164</li>
<li>By value . . . . . 164</li>
<li>By constant value (fastest) . . . . . 165</li>
<li>By constant reference . . . . . 165</li>
<li>Out parameters . . . . . 166</li>
<li>Default parameters . . . . . 166</li>
<li>Playing more with parameters of a routine . . . . . 167</li></ul>
<p>12. Classes and objects . . . . . 171</p>
<ul>
<li>Why objects? . . . . . 171</li>
<li>An object . . . . . 171</li>
<li>Objects vs classes . . . . . 172</li>
<li>Naming conventions . . . . . 172</li>
<li>Instantiation . . . . . 172</li>
<li>Extensibility . . . . . 173</li>
<li>Constructors . . . . . 173</li>
<li>Let's build our own class: . . . . . 174</li>
<li>Inherited . . . . . 174</li>
<li>Destructors . . . . . 175</li>
<li>Try/Finally . . . . . 175</li>
<li>Super-duper important . . . . . 176</li>
<li>Special cases . . . . . 176</li>
<li>Fields . . . . . 178</li>
<li>Properties . . . . . 178</li>
<li>Read-only properties . . . . . 180</li>
<li>Recap . . . . . 181</li>
<li>Published properties . . . . . 181</li>
<li>Default . . . . . 182</li>
<li>Manual memory management for objects . . . . . 182</li>
<li>Pointers . . . . . 187</li>
<li>Typed vs untyped pointers . . . . . 188</li>
<li>Dereferencing a pointer . . . . . 188</li>
<li>Assigning pointers . . . . . 189</li>
<li>References . . . . . 192</li>
<li>Dangling references . . . . . 194</li>
<li>Assigning an object to another object . . . . . 195</li>
<li>Objects – A real world example . . . . . 198</li>
<li>Inheritance, polymorphism, and typecasting . . . . . 199</li>
<li>The inheritance chain . . . . . 199</li>
<li>Typecasting . . . . . 201</li>
<li>The hard typecast . . . . . 202</li>
<li>The 'as' typecast . . . . . 203</li>
<li>The 'is' operator . . . . . 204</li>
<li>Invalid typecasts . . . . . 205</li>
<li>More invalid typecasts . . . . . 205</li>
<li>RTTI alternative . . . . . 206</li>
<li>Methods . . . . . 207</li>
<li>Method binding . . . . . 207</li>
<li>Speed . . . . . 208</li>
<li>Static methods . . . . . 208</li>
<li>Overriding methods / Polymorphic behavior . . . . . 209</li>
<li>Polymorphism . . . . . 211</li>
<li>Hiding vs overriding . . . . . 212</li>
<li>VMT . . . . . 214</li>
<li>Overloading methods . . . . . 215</li>
<li>Recap for polymorphism . . . . . 217</li>
<li>Another experiment . . . . . 217</li>
<li>Declaring multiple constructors with the same name . . . . . 218</li>
<li>Keywords recap . . . . . 220</li>
<li>Methods - Advanced topics . . . . . 221</li>
<li>Class methods . . . . . 221</li>
<li>Concrete example . . . . . 221</li>
<li>Let's write a better example . . . . . 223</li>
<li>Class fields . . . . . 224</li>
<li>Putting class fields to a good use - Singleton class . . . . . 225</li>
<li>One more example . . . . . 225</li>
<li>Predefined class methods in TObject . . . . . 226</li>
<li>Abstract methods . . . . . 227</li>
<li>Abstract classes . . . . . 230</li>
<li>Generics . . . . . 230</li>
<li>Creating a generic class . . . . . 232</li></ul>
<p>13. Forms . . . . . 234</p>
<ul>
<li>PAS + DFM = Form . . . . . 234</li>
<li>Auto-created forms . . . . . 236</li>
<li>The main form . . . . . 236</li>
<li>Secondary forms . . . . . 237</li>
<li>Stay on top . . . . . 240</li>
<li>The “Application” object . . . . . 240</li>
<li>Showing a new created form . . . . . 241</li>
<li>The owner of a form . . . . . 241</li>
<li>Application as owner . . . . . 241</li>
<li>Form as owner . . . . . 242</li>
<li>Nil as owner (no owner) . . . . . 242</li>
<li>Form initialization . . . . . 242</li>
<li>Closing a form . . . . . 246</li>
<li>Several ways to close a form . . . . . 247</li>
<li>Release versus Close . . . . . 248</li>
<li>About GUI Applications . . . . . 249</li>
<li>So, why do we need GUIs? . . . . . 249</li>
<li>Save GUI state to file . . . . . 258</li>
<li>User selectable styles . . . . . 258</li>
<li>Summary . . . . . 259</li></ul>
<p>14. Visual components . . . . . 260</p>
<ul>
<li>Parenting and Ownership . . . . . 261</li>
<li>Parenting and modularization . . . . . 262</li>
<li>Ownership vs Parenting . . . . . 264</li>
<li>Properties of a component . . . . . 264</li>
<li>Building our own visual component . . . . . 265</li>
<li>Event handlers . . . . . 267</li>
<li>The ubiquitous Sender parameter . . . . . 270</li>
<li>Most used visual components . . . . . 271</li>
<li>TLabel . . . . . 272</li>
<li>TButton . . . . . 272</li>
<li>TPanel . . . . . 272</li>
<li>TRadioButton . . . . . 273</li>
<li>TCheckBox . . . . . 273</li>
<li>TImage . . . . . 273</li>
<li>TEdit . . . . . 274</li>
<li>TMemo . . . . . 274</li>
<li>TRichEdit . . . . . 274</li>
<li>TSpinEdit . . . . . 275</li>
<li>Visual Components (advanced) . . . . . 275</li>
<li>TTrayIcon . . . . . 275</li>
<li>TFlowPanel . . . . . 278</li>
<li>TGridPanel . . . . . 280</li>
<li>Actions / TActionList . . . . . 282</li>
<li>TActionManager . . . . . 289</li></ul>
<p>15. The Delphi compiler . . . . . 297</p>
<ul>
<li>What is a compiler? What is an interpreter? . . . . . 297</li>
<li>A reliable compiler . . . . . 297</li>
<li>The toolchain . . . . . 298</li>
<li>Executable size . . . . . 298</li>
<li>Compiler speed . . . . . 299</li>
<li>Improve compiler’s speed . . . . . 299</li>
<li>From Pas to Exe . . . . . 301</li>
<li>The compilation order . . . . . 302</li>
<li>Running the program . . . . . 303</li>
<li>DCUs . . . . . 303</li>
<li>The linker . . . . . 303</li>
<li>Compile vs Build . . . . . 304</li>
<li>Debug vs Release DCUs . . . . . 304</li>
<li>Release-mode . . . . . 304</li>
<li>Debug-mode . . . . . 305</li>
<li>The Debug information . . . . . 305</li></ul>
<p>16. Libraries . . . . . 307</p>
<ul>
<li>Library architecture . . . . . 307</li>
<li>It is all about aliens and pyramids . . . . . 309</li>
<li>The files of a library . . . . . 310</li>
<li>DPK . . . . . 310</li>
<li>GroupProj . . . . . 310</li>
<li>BPL . . . . . 311</li>
<li>Using libraries in our projects . . . . . 311</li>
<li>The RTL library . . . . . 312</li>
<li>The VCL library . . . . . 312</li>
<li>Library paths . . . . . 313</li>
<li>Environment variables . . . . . 313</li>
<li>The “Library” settings . . . . . 313</li>
<li>The “Library path” field . . . . . 315</li>
<li>The “Package/DCP/HPP output directory” fields . . . . . 318</li>
<li>The “Browsing path” field . . . . . 318</li>
<li>The “Debug DCU path” field . . . . . 320</li>
<li>Debugger Source Path . . . . . 320</li>
<li>Precompiled files . . . . . 320</li>
<li>The “Use debug DCUs” field . . . . . 321</li>
<li>Precompiling our own files . . . . . 322</li>
<li>The “Debug source path” field . . . . . 323</li>
<li>Project Paths . . . . . 325</li>
<li>How to install a library? . . . . . 326</li>
<li>Installing a library . . . . . 326</li>
<li>Adding library’s folder to the “Search path” . . . . . 327</li>
<li>Installers . . . . . 329</li>
<li>Installing libraries via GetIt . . . . . 329</li>
<li>How to uninstall a library from Delphi . . . . . 331</li>
<li>Runtime/Designtime libraries . . . . . 332</li>
<li>Run-time libraries . . . . . 332</li>
<li>Design time libraries . . . . . 332</li>
<li>Design time vs Run time . . . . . 333</li>
<li>How to use a library in our projects? . . . . . 334</li>
<li>About libraries and licenses . . . . . 335</li>
<li>Discussions . . . . . 337</li>
<li>Conclusions . . . . . 338</li>
<li>More details . . . . . 338</li>
<li>Dynamic Link Libraries (BPLs) in Delphi . . . . . 338</li>
<li>Link with runtime packages . . . . . 339</li>
<li>Separating Libraries from Projects . . . . . 341</li>
<li>The libraries are “global” . . . . . 341</li>
<li>Debugging 3rd party libraries . . . . . 342</li>
<li>Using C/++ libraries in Delphi . . . . . 343</li>
<li>Popular libraries . . . . . 345</li>
<li>FastMM4 . . . . . 345</li>
<li>Graphics32 . . . . . 346</li>
<li>Delphi LightSaber . . . . . 346</li>
<li>Jedi . . . . . 346</li>
<li>LightSaber . . . . . 347</li>
<li>Freeware . . . . . 347</li>
<li>Sub-libraries . . . . . 348</li>
<li>LightSaber Core . . . . . 349</li>
<li>LightSaber Log . . . . . 351</li>
<li>LightSaber Common . . . . . 352</li>
<li>LightSaber Internet . . . . . 353</li>
<li>Filename convention used in Delphi LightSaber . . . . . 354</li>
<li>Proteus . . . . . 354</li>
<li>What is Proteus? . . . . . 354</li>
<li>What can Proteus do for us? . . . . . 355</li>
<li>How to use it? . . . . . 355</li>
<li>Proteus details . . . . . 357</li>
<li>Setting up your app . . . . . 360</li>
<li>Advanced topics . . . . . 362</li>
<li>Certificate ID . . . . . 364</li>
<li>Active certificate . . . . . 365</li></ul>
<p>17. The debugger . . . . . 366</p>
<ul>
<li>What is a debugger? . . . . . 366</li>
<li>Preparing our project for debugging . . . . . 366</li>
<li>Stacks . . . . . 366</li>
<li>Configurations . . . . . 368</li>
<li>The “Compiling” page . . . . . 369</li>
<li>Other settings . . . . . 371</li>
<li>A picture is worth a thousand words . . . . . 371</li>
<li>The “Linking” page . . . . . 373</li>
<li>Debugger Source Path . . . . . 374</li>
<li>Breakpoints . . . . . 375</li>
<li>Breakpoint properties . . . . . 377</li>
<li>Relocate the execution point manually . . . . . 378</li>
<li>Finally, ready to debug . . . . . 379</li>
<li>Starting the program under the debugger . . . . . 379</li>
<li>Debugging from a crash point . . . . . 380</li>
<li>Cannot debug? . . . . . 383</li>
<li>Fun stuff to do during debugging . . . . . 384</li>
<li>Hint for geeks . . . . . 386</li>
<li>Debugging cheat sheet . . . . . 387</li></ul>
<p>18. Remote debugging . . . . . 389</p>
<ul>
<li>How does it work? . . . . . 389</li>
<li>Install PAserver (on the remote machine) . . . . . 390</li>
<li>Run PAServer (on the remote machine) . . . . . 390</li>
<li>Configure the environment (locally) . . . . . 391</li>
<li>Assign a Connection Profile to the Delphi project . . . . . 394</li>
<li>Choose which files to deploy . . . . . 396</li>
<li>Deploying the files manually . . . . . 396</li>
<li>Start debugging . . . . . 396</li>
<li>Stability . . . . . 397</li></ul>
<p>19. Automatic bug reporting . . . . . 399</p>
<ul>
<li>MadShi MadExcept . . . . . 400</li>
<li>EurekaLog . . . . . 403</li></ul>
<p>20. Advanced debugging techniques . . . . . 405</p>
<ul>
<li>How to debug your components/the IDE? . . . . . 405</li>
<li>Method 1: Attach to process . . . . . 405</li>
<li>Method 2: Debug with “Run -> Load process”. 406</li>
<li>Method 3: External tools . . . . . 410</li>
<li>Method 4: Start Delphi in “safe” mode . . . . . 411</li>
<li>Stupid Windows 10 . . . . . 411</li></ul>
<p>21. Speed up your program . . . . . 412</p>
<ul>
<li>Profiling your program . . . . . 413</li>
<li>Home-brewed method (as cheap as the home-made beer) . . . . . 413</li>
<li>Third party profilers (aka non-free) . . . . . 415</li>
<li>Improving the speed . . . . . 416</li>
<li>Record field alignment . . . . . 416</li>
<li>CPU Optimization . . . . . 419</li>
<li>Compared to Julia . . . . . 420</li></ul>
<p>22. Compiler! Please save my ass! . . . . . 426</p>
<ul>
<li>Overflow checking . . . . . 427</li>
<li>IO checking . . . . . 428</li>
<li>Range Checking . . . . . 428</li>
<li>Enabling Runtime Error Checking . . . . . 428</li>
<li>Assertions . . . . . 429</li>
<li>Nothing comes for free . . . . . 431</li></ul>
<p>23. Memory management . . . . . 432</p>
<ul>
<li>FastMM . . . . . 432</li>
<li>1. Dramatic speed increase for memory-bound operations . . . . . 432</li>
<li>2. Prevents memory fragmentation . . . . . 432</li>
<li>3. Better memory sharing . . . . . 433</li>
<li>4. Safer code . . . . . 433</li>
<li>5. No more access violations . . . . . 436</li>
<li>Switching FastMM to Full Debug Mode . . . . . 437</li>
<li>How to read a FastMM leak report? . . . . . 437</li>
<li>The summary . . . . . 439</li>
<li>Leaked blocks . . . . . 439</li>
<li>Advanced topics . . . . . 442</li>
<li>You create it, you kill it . . . . . 442</li>
<li>Memory ownership . . . . . 442</li>
<li>Dangling references . . . . . 443</li>
<li>Alice loses her preferred book . . . . . 443</li>
<li>Getting our dirty paws on a dangling reference . . . . . 444</li>
<li>The root of all evil . . . . . 446</li>
<li>There are even worst scenarios . . . . . 447</li>
<li>Do some noise . . . . . 447</li>
<li>Bruce Willis (and FastMM) saves the day... again! . . . . . 449</li>
<li>Garbage collectors . . . . . 450</li>
<li>About ownership . . . . . 450</li>
<li>Passing the ownership around . . . . . 451</li>
<li>Summary . . . . . 453</li></ul>
<p>24. Exceptions . . . . . 454</p>
<ul>
<li>Exception Handling . . . . . 456</li>
<li>Let’s do the “What this code does” game . . . . . 459</li>
<li>Amateur mistake . . . . . 461</li>
<li>Keep it real . . . . . 463</li>
<li>Spit, don't swallow . . . . . 463</li>
<li>Good boy, Debugger! . . . . . 464</li>
<li>Ignoring exceptions during debugging . . . . . 465</li>
<li>Try/Finally vs Try/Except . . . . . 467</li>
<li>Raising exceptions . . . . . 469</li></ul>
<p>25. Windows Messages in Delphi . . . . . 471</p>
<ul>
<li>The Windows Messaging System . . . . . 471</li>
<li>Message Handlers in Delphi . . . . . 471</li>
<li>Practical Examples . . . . . 472</li></ul>
<p>26. Programmer’s toolbox . . . . . 474</p>
<ul>
<li>Delphi registry secret . . . . . 474</li>
<li>How to start a “mint” Delphi instance? . . . . . 475</li>
<li>Total Commander . . . . . 476</li>
<li>SoftPerfect RAMDisk . . . . . 478</li>
<li>Version control . . . . . 479</li>
<li>Do we need a repository? . . . . . 480</li>
<li>Creating a new Tortoise repository . . . . . 482</li>
<li>Revisions . . . . . 484</li>
<li>Resolving Conflicts . . . . . 485</li>
<li>Commit Progress . . . . . 486</li>
<li>Icon overlays . . . . . 486</li>
<li>Shelving . . . . . 486</li>
<li>Normalizers . . . . . 487</li></ul>
<p>27. Code safety . . . . . 490</p>
<ul>
<li>Things that are ok, but dangerous . . . . . 490</li>
<li>Delphi language . . . . . 491</li>
<li>“Simply don’t do it” . . . . . 494</li>
<li>Letting the compiler to help us . . . . . 494</li>
<li>Extra techniques . . . . . 495</li>
<li>Program architecture . . . . . 495</li>
<li>Some details . . . . . 496</li>
<li>On FreeAndNil . . . . . 497</li>
<li>A word of warning on Application.ProcessMessages . . . . . 498</li></ul>
<p>28. Advance topics . . . . . 500</p>
<ul>
<li>Running a single instance of our program . . . . . 500</li>
<li>How does it work? . . . . . 500</li>
<li>Let’s see the code . . . . . 501</li>
<li>Anonymous methods . . . . . 502</li>
<li>Capture of Variables . . . . . 503</li>
<li>Usage . . . . . 503</li>
<li>Flexible Usage . . . . . 504</li>
<li>Inline Definitions . . . . . 504</li>
<li>Analyzing the code above . . . . . 504</li></ul>
<p> . . . . . 29. Migrating 32-bit Code to 64-bit: Best Practices and Considerations . . . . . 506</p>
<ul>
<li>Before you start . . . . . 506</li>
<li>Upgrading Third-Party Libraries . . . . . 506</li>
<li>Adding 64-bit Support to the Project . . . . . 506</li>
<li>Fixing the paths . . . . . 506</li>
<li>Inspecting the code . . . . . 507</li>
<li>Choosing the correct data types . . . . . 507</li>
<li>Typecast from pointer to integer . . . . . 508</li>
<li>Typecast between Record and TObject . . . . . 509</li>
<li>WinAPI issues . . . . . 509</li>
<li>SendMessage . . . . . 510</li>
<li>Vcl.Controls.TControl.Perform . . . . . 510</li>
<li>SetWindowLong/ GetWindowLong . . . . . 511</li>
<li>SetWindowLong: . . . . . 511</li>
<li>Avoid using LongInt . . . . . 512</li>
<li>Extended type . . . . . 512</li>
<li>Inline ASM code . . . . . 513</li>
<li>Functions that return Cardinal instead of Pointer . . . . . 513</li>
<li>Summary . . . . . 513</li></ul>
<p>30. Deploying our application on other platforms . . . . . 515</p>
<ul>
<li>Android . . . . . 515</li>
<li>Apple . . . . . 515</li>
<li>Linux . . . . . 516</li>
<li>Summary . . . . . 516</li></ul>
<p>31. Being a programmer . . . . . 517</p>
<p>32. All good things must come to an end . . . . . 522</p>
<ul>
<li>Where do you go from here? . . . . . 522</li>
<li>Your next big project could be a game . . . . . 522</li>
<li>About Stack Overflow . . . . . 523</li>
<li>Fighting bullies on Stack Overflow . . . . . 523</li>
<li>Ask the artificial intelligence . . . . . 524</li>
<li>Video tutorials . . . . . 527</li>
<li>Books . . . . . 527</li>
<li>My books . . . . . 527</li>
<li>Already published books: . . . . . 528</li>
<li>What I have learned in the last 25 years of software development . . . . . 528</li></ul>
<p>33. Appendix . . . . . 532</p>
<ul>
<li>Files generated by Delphi . . . . . 532</li>
<li>Example of ASM code in Pas file: . . . . . 533</li>
<li>Delphi releases . . . . . 534</li>
<li>What's new since Delphi 10.0? . . . . . 535</li></ul>
<p>34. Notes and credits . . . . . 539</p>
<ul>
<li>Contact me! . . . . . 539</li>
<li>Disclaimer . . . . . 539</li>
<li>Source code . . . . . 539</li>
<li>Be environment responsible . . . . . 539</li>
<li>Credits . . . . . 539</li></ul></div>
</div>
<footer>
<p><a href="../opendata.html">Open data / API</a><br>
<a href="index.html">Delphi-Books.com</a> &copy; 2020-2023 <a href="https://olfsoftware.fr">Olf Software</a> / <a href="https://developpeur-pascal.fr">Developpeur-Pascal.fr</a></p>
</footer>
</div>
</body>
</html>