{
"id":121,
"url":"",
"guid":"7CE5FCB8DA18EE118C5C32A5A9F17050",
"pagename":"Writing-an-Interpreter-in-Object-Pascal-Part-1-Lexical-and-Basic-Syntax-Analysis.html",
"datalevel":8,
"dataversion":1,
"ispagetobuild":true,
"name":"Writing an Interpreter in Object Pascal: Part 1: Lexical and Basic Syntax Analysis",
"lang":"en",
"pubdate":"20190106",
"thumb":"",
"isbn10":"1732548609",
"isbn13":"9781732548602",
"website":"https:\/\/www.objectpascalinterpreter.com\/part-i",
"cover":"",
"cover_100w":"",
"cover_150w":"",
"cover_200w":"",
"cover_300w":"",
"cover_400w":"",
"cover_500w":"",
"cover_100h":"",
"cover_200h":"",
"cover_300h":"",
"cover_400h":"",
"cover_500h":"",
"cover_100x100":"",
"cover_200x200":"",
"cover_300x300":"",
"cover_400x400":"",
"cover_500x500":"",
"cover_130x110":"",
"authors":[
{
"id":84,
"url":"",
"guid":"22E5FCB8DA18EE118C5C32A5A9F17050",
"pagename":"Herbert-Sauro.html",
"datalevel":6,
"dataversion":1,
"ispagetobuild":true,
"name":""}],
"publishers":[
],
"descriptions":[
{
"guid":"EAE5FCB8DA18EE118C5C32A5A9F17050",
"pagename":"",
"datalevel":3,
"dataversion":1,
"ispagetobuild":true,
"lang":"en",
"text":"<p>This is part 1 of a series that will show you how to write an interactive interpreter in Object Pascal. Part 1 of the series will cover introductory material including a description of the language we\u2019ll create, a full lexical analyzer for the language, how to use DUnitX for unit testing, and an introduction to the essential concepts in syntax analysis, recursive descent, grammar, and EBNF.  Along the way, we\u2019ll create a simple REPL, give a detailed discussion of how to parse expressions and build a simple interactive calculator to illustrate the theory. The book provides fully working code and explains in plain English how the code works and why certain decisions were made, including alternative designs. The book makes liberal use of code throughout the book chapters.   Everything is done without the help of third-party tools such as Yacc, ANTLR or Flex. All you need is a standard installation of Free Pascal or Embarcaderos\u2019s Delphi (including the free community edition).<\/p>\n<p>The text is geared to hobbyists and midlevel developers who need an accessible introduction to lexical analysis and parsing.  It\u2019s also for students starting out in compiler and interpreter design and need something more digestible.<\/p>\n<p>All <a href=\"https:\/\/github.com\/ObjectPascalInterpreter\/BookPart_1\">source code<\/a> is open source under Apache 2.0 and available from Github.<\/p>"}],
"tocs":[
{
"guid":"12E6FCB8DA18EE118C5C32A5A9F17050",
"pagename":"",
"datalevel":3,
"dataversion":1,
"ispagetobuild":true,
"lang":"en",
"text":"<p>Introduction<br>\na) Why Object Pascal<br>\nb) What is an interpreter<br>\nc) Parts of an interpreter<br>\nThe Rhodus Language<br>\nLexical Analysis<br>\nInitial API<br>\nInput streams<br>\nRetrieving tokens<br>\nFirst run<br>\nAdding more tokens<br>\nTesting<br>\nIntroduction to testing<br>\nUsing DUnitX<br>\nAn Interactive Console<br>\nIntroduction to Syntax Analysis<br>\nGrammar<br>\nProduction rules<br>\nLL(k)<br>\nRecursive descent<br>\nFactoring, the dangling else<br>\nLeft recursion<br>\nAmbiguous Grammars<br>\nA simple calculator<br>\nSyntax trees<br>\nAdding exponentiation and the unary minus<br>\nTesting the Calculator<br>\nAdding Assignments and Variables<br>\nUsing a queue for token lookahead<br>\nUpdating the syntax analyzer<br>\nUpdating the lexical analyzer<br>\nBuilding a Recognizer<br>\nAppendix EBNF<\/p>"}],
"keywords":[
]}