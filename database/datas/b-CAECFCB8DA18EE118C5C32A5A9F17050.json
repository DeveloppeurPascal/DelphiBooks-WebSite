{
"id":125,
"url":"",
"guid":"CAECFCB8DA18EE118C5C32A5A9F17050",
"pagename":"Delphi-Legacy-Projects-Strategies-and-Survival-Guide.html",
"datalevel":8,
"dataversion":1,
"ispagetobuild":true,
"name":"Delphi Legacy Projects : Strategies and Survival Guide",
"lang":"en",
"pubdate":"20220602",
"thumb":"",
"isbn10":"",
"isbn13":"9798833375693",
"website":"https:\/\/wmeyer.tech\/books\/",
"cover":"",
"cover_100w":"",
"cover_150w":"",
"cover_200w":"",
"cover_300w":"",
"cover_400w":"",
"cover_500w":"",
"cover_100h":"",
"cover_200h":"",
"cover_300h":"",
"cover_400h":"",
"cover_500h":"",
"cover_100x100":"",
"cover_200x200":"",
"cover_300x300":"",
"cover_400x400":"",
"cover_500x500":"",
"cover_130x110":"",
"authors":[
{
"id":86,
"url":"",
"guid":"48ECFCB8DA18EE118C5C32A5A9F17050",
"pagename":"William-Meyer.html",
"datalevel":6,
"dataversion":1,
"ispagetobuild":true,
"name":""}],
"publishers":[
],
"descriptions":[
{
"guid":"42EDFCB8DA18EE118C5C32A5A9F17050",
"pagename":"",
"datalevel":3,
"dataversion":1,
"ispagetobuild":true,
"lang":"en",
"text":"<p>Delphi has been in wide use for over 25 years, and there are many legacy projects which are still in active production. This volume offers approaches to refactoring and modernizing the code base without the need for complete redesign and rewrite. Evolution, not revolution. These are approaches well suited to the incremental revision of production code, as is usually the concern with a commercial product.<\/p>\n<p>A paper book is available from Amazon but you also can <a href=\"https:\/\/wmeyer.tech\/books\/\">buy a PDF from author's website<\/a>.<\/p>"}],
"tocs":[
{
"guid":"74EDFCB8DA18EE118C5C32A5A9F17050",
"pagename":"",
"datalevel":3,
"dataversion":1,
"ispagetobuild":true,
"lang":"en",
"text":"<p>Contents<\/p>\n<p>Preface<\/p>\n<p>1 Frame of Reference<br>\n1.1 Your Current Practice<br>\n1.2 More Thoughtful Coding<\/p>\n<p>2 Introducing the Problem<br>\n2.1 Purpose and Perspective<br>\n2.2 Areas of Difficulty<br>\n2.2.1 Evolution, not Revolution<br>\n2.3 We May Be the Enemy<br>\n2.3.1 Too Many Components?<br>\n2.3.2 Abusing the Search Path<br>\n2.3.3 Coding Too Soon?<br>\n2.3.4 Inheritance<br>\n2.3.5 Excessive Coupling<br>\n2.3.6 Unit Dependency Cycles<br>\n2.4 The IDE, Again<\/p>\n<p>3 Strategies<br>\n3.1 Philosophy and Reality<br>\n3.2 Setting Goals<br>\n3.2.1 Patience<br>\n3.3 Select Your Components<br>\n3.4 Pre-convert, if Necessary<br>\n3.5 Isolate Your Code<br>\n3.6 Achieving a Build<br>\n3.7 Module Inclusion<br>\n3.8 Separating Projects - How and Why<br>\n3.8.1 Multiple Projects in One Delphi Version<br>\n3.8.2 Multiple Projects in Multiple Delphi Versions<br>\n3.9 Start Small<br>\n3.10 Incremental Change<br>\n3.11 Strip Deadwood<\/p>\n<p>4 Beginning<br>\n4.1 The IDE<br>\n4.2 The Build Process<br>\n4.2.1 Build Management<br>\n4.2.2 Accept Compiler Advice<br>\n4.3 Data and Code<br>\n4.3.1 Scope of Data<br>\n4.3.2 Writeable \u201CConstants\u201D<br>\n4.4 Scope in General<br>\n4.4.1 Forms vs. Units<br>\n4.4.2 Proper to Forms<br>\n4.4.3 Proper to Class Units<br>\n4.4.4 Proper to Data Modules<br>\n4.4.5 Everything Private!<br>\n4.4.6 Global not Always Bad<br>\n4.4.7 Partitioning<br>\n4.5 Exception Handling<br>\n4.5.1 A Simple Example<br>\n4.5.2 Exceptional Failures<br>\n4.5.3 Exceptional Confusion<br>\n4.5.4 Scope of Exception Handlers<br>\n4.5.5 Default Exception Handlers<br>\n4.6 Code Formatting<br>\n4.6.1 Formatting Matters<br>\n4.6.2 Manageable Formatting<br>\n4.6.3 Minor Formatting<\/p>\n<p>Digging Into the Challenges<\/p>\n<p>5 Comments<br>\n5.1 Useless Comments<br>\n5.2 Annoying Comments<br>\n5.3 Thoughtless Comments<br>\n5.4 Essential Comments<\/p>\n<p>6 Cleaning Uses Clauses<br>\n6.1 Initialization<br>\n6.1.1 Independent Factors<br>\n6.1.2 Initialization of Units<br>\n6.2 Removing Dead and Duplicate Units<br>\n6.2.1 ProjectFiles Tool<br>\n6.2.2 Other Useful Tools<br>\n6.3 Removing and Demoting Unit References<br>\n6.4 Using the Tools<br>\n6.5 Unit Dependency Cycles<br>\n6.6 Collecting the UDCs<\/p>\n<p>7 Simple Things<br>\n7.1 Structural Changes in Delphi<br>\n7.2 Hints and Warnings<br>\n7.3 Types and Constants<br>\n7.3.1 No Magic Numbers<br>\n7.3.2 Unicode?<br>\n7.3.3 Numeric Type Aliases<br>\n7.3.4 Global can be OK<br>\n7.3.5 Assignment Compatibility<br>\n7.3.6 Use Enumerations<br>\n7.3.7 Use Sets<br>\n7.3.8 Use Defined Ranges<br>\n7.4 Variables and Scope<br>\n7.4.1 Avoid Global Variables<br>\n7.4.2 Using AOwner<br>\n7.5 Forms<br>\n7.5.1 Form Variables<br>\n7.5.2 Form File Format<br>\n7.6 Delphi Versions<\/p>\n<p>8 Not so Simple Things<br>\n8.1 Persistence in Settings<br>\n8.1.1 Persistence with Enumerations<br>\n8.2 Dangers in Use of ClassName<br>\n8.2.1 Decoupling with a Dictionary<br>\n8.3 Reviewing Code<\/p>\n<p>9 Cleaning Legacy Code<br>\n9.1 Local Variables<br>\n9.1.1 I\/O Checking<br>\n9.1.2 Overflow Checking<br>\n9.1.3 Range Checking<br>\n9.1.4 Rename Local Variables<br>\n9.1.5 Remove Local Variables<br>\n9.2 Remove Wrappers<br>\n9.3 Coding Style<br>\n9.4 Form State<br>\n9.4.1 Form State Components<br>\n9.5 Form vs. Code Dependency<br>\n9.6 Types & Consts Again<br>\n9.6.1 Doppelgangers<br>\n9.7 Misplaced Routines<\/p>\n<p>10 Local Components<br>\n10.1 Component Basics<br>\n10.2 Managing Components<br>\n10.3 Component Pitfalls<br>\n10.3.1 Components Doing Too Much<br>\n10.3.2 Bad Assumptions<br>\n10.3.3 Failing to Handle Exceptions<br>\n10.3.4 Mixing Component and Application Code<br>\n10.4 Cleaning House<br>\n10.4.1 Use Library Modules<br>\n10.4.2 Keep the interface uses Clause Small<br>\n10.4.3 Refactor Utility Units<\/p>\n<p>11 Refactoring<br>\n11.1 A Workable Approach to Small Change<br>\n11.2 The Value of a Data Module<br>\n11.3 Testing in a Data Module<br>\n11.3.1 Information Hiding<br>\n11.3.2 Minimizing Points of Contact<br>\n11.4 The Challenge of Testing<br>\n11.4.1 Massive Routines<br>\n11.4.2 Massive Coupling<br>\n11.4.3 Risk is Unavoidable<br>\n11.5 Code for the Maintainer<br>\n11.5.1 Resources<br>\n11.6 Prefer Library Code<br>\n11.7 Use Nested Routines<br>\n11.8 Extract Classes<br>\n11.9 Prefer Composition<br>\n11.9.1 The Public Interface<br>\n11.9.2 The Private Behaviors<br>\n11.9.3 Notes on Implementation<\/p>\n<p>12 Removing Code from Forms<br>\n12.1 Extract Utility Routines<br>\n12.1.1 Refactoring Praxis<br>\n12.2 Building Utility Units<br>\n12.3 Shared Classes<br>\n12.4 Use Data Modules<br>\n12.4.1 Common Operations<br>\n12.5 Separate Business Logic<br>\n12.5.1 What is Business Logic?<br>\n12.5.2 Organization<br>\n12.5.3 Separate Data Handling<\/p>\n<p>13 Fixing Erroneous Coding<br>\n13.1 Errors of Function<br>\n13.2 Reduce Noise<br>\n13.3 Reduce Logic<br>\n13.3.1 Using Partial Products<br>\n13.3.2 Prefer Positive Logic<br>\n13.4 Loop Forms<br>\n13.5 Minimize Tests<br>\n13.6 Use Arrays<br>\n13.6.1 Static Arrays<br>\n13.6.2 Dynamic Arrays<br>\n13.6.3 Open Arrays<br>\n13.6.4 Generic Arrays<br>\n13.6.5 Constant Arrays<br>\n13.6.6 Arrays vs. Cases<br>\n13.7 Summary<\/p>\n<p>14 Class and Record Helpers<br>\n14.1 Alternative Approaches<br>\n14.2 TStringHelper<br>\n14.3 Legacy Cleanup<br>\n14.4 More Insights<\/p>\n<p>15 Using Datasets Well<br>\n15.1 TField Properties<br>\n15.2 Component Differences<br>\n15.3 Normalize Data<br>\n15.4 Less Specificity<br>\n15.5 Think Before Coding<\/p>\n<p>16 Pragmatism<br>\n16.1 Assessing the Costs<br>\n16.2 Measuring Value<br>\n16.2.1 Use EurekaLog<br>\n16.2.2 Use Analytics<br>\n16.3 Missing Source Code<br>\n16.4 Analytical Modules<br>\n16.5 Little-Used Modules<\/p>\n<p>17 Interfaces<br>\n17.1 History<br>\n17.2 Reducing Scope<br>\n17.2.1 Constants and Types<br>\n17.2.2 Properties<br>\n17.3 Managing Memory<br>\n17.4 Examples<br>\n17.5 Going Deeper<br>\n17.5.1 Variations<\/p>\n<p>18 Testability<br>\n18.1 Testing Legacy Code<br>\n18.2 Layers of Difficulty<br>\n18.3 Design Specifications<br>\n18.4 Interdependency Issues<br>\n18.5 Coupling, Partitioning<br>\n18.6 Code on Forms<br>\n18.7 Testability Defined<br>\n18.8 Ensure Testability<br>\n18.9 Unit Test Frameworks<br>\n18.10 Testing Practices<\/p>\n<p>19 Performance<br>\n19.1 Realities<br>\n19.1.1 Profiling<br>\n19.1.2 Profiling Legacy Code<br>\n19.1.3 Approaching Profiling<br>\n19.2 Painful Realities<br>\n19.3 You Need Tools<\/p>\n<p>20 Disruptive Forces<br>\n20.1 Code Details<br>\n20.1.1 Hints and Warnings<br>\n20.1.2 Static Analysis<br>\n20.2 Component Issues<br>\n20.2.1 Orphaned Components<br>\n20.2.2 Local Components<br>\n20.3 Dependency Cycles<br>\n20.3.1 The Gordian Knot<br>\n20.3.2 Small Steps<br>\n20.3.3 Larger Steps<br>\n20.3.4 Cycles in Components<br>\n20.4 Compiler Versions<br>\n20.5 Issues You must Find<\/p>\n<p>Best Practices<\/p>\n<p>21 Some Simple Principles<br>\n21.1 Principle of Least Astonishment<br>\n21.2 DRY: Don\u2019t Repeat Yourself<br>\n21.2.1 The Rule of Three<br>\n21.2.2 Causes of Repetition<br>\n21.2.3 Using the Libraries<br>\n21.2.4 String Utilities<br>\n21.2.5 Date and Time Utilities<br>\n21.3 YAGNI: You Ain\u2019t Gonna Need It<br>\n21.4 SOC: Separation of Concerns<\/p>\n<p>22 SOLID<br>\n22.1 What is SOLID?<br>\n22.1.1 Single Responsibility<br>\n22.1.2 Open\/Closed<br>\n22.1.3 Liskov Substitution<br>\n22.1.4 Interface Segregation Principle<br>\n22.1.5 Dependency Inversion<\/p>\n<p>23 Inheritance, Aggregation, Composition<br>\n23.1 Inheritance<br>\n23.2 Composition<br>\n23.3 Aggregation<\/p>\n<p>24 Design Patterns<br>\n24.1 Anti-patterns<br>\n24.2 Delphi Idioms<br>\n24.2.1 Create\/Destroy<br>\n24.2.2 If\/Else<br>\n24.2.3 Helpers<br>\n24.2.4 Smart Pointers<br>\n24.3 Recommended Practices<br>\n24.4 Patterns of Interest<br>\n24.4.1 Adapter Pattern<br>\n24.4.2 Facade Pattern<br>\n24.4.3 Dependency Injection<br>\n24.5 Summary<\/p>\n<p>25 Dependency Injection<br>\n25.1 Starting Small<br>\n25.2 Types of Injection<br>\n25.2.1 Constructor Injection<br>\n25.2.2 Property Injection<br>\n25.2.3 Method Injection<br>\n25.3 Summary<\/p>\n<p>26 Unit Testing<br>\n26.1 DUnit<br>\n26.2 DUnit2<br>\n26.3 DUnitX<br>\n26.4 TestInsight<br>\n26.5 Delphi Mocks<\/p>\n<p>Appendix: Tools<\/p>\n<p>27 Tools Overview<br>\n27.1 IDE Plug-ins<br>\n27.2 Standalone<br>\n27.3 Some Disclaimers<\/p>\n<p>28 CnPack<br>\n28.1 Structural Highlighting<br>\n28.2 Tab Order<br>\n28.3 Uses Cleaner<br>\n28.4 CnPack Summary<\/p>\n<p>29 CodeSite<br>\n29.1 Details in Your Hands<br>\n29.2 Data from the Field<br>\n29.3 Simple Example<\/p>\n<p>30 Delphi Mocks<br>\n30.1 Delphi Mocks in Use<br>\n30.2 Why Mock?<br>\n30.3 When to Mock<br>\n30.4 Summary<\/p>\n<p>31 Documentation Insight<\/p>\n<p>32 Delphi Unit Dependency Scanner<\/p>\n<p>33 DUNIT<br>\n33.1 DUnit in Recent IDEs<br>\n33.2 Developing Test Cases<br>\n33.3 Start with the Familiar<br>\n33.4 Coverage in Legacy Projects<br>\n33.5 Test Driven Development<br>\n33.6 Unit Test Lifetime<br>\n33.7 Summary<\/p>\n<p>34 DUnit2<\/p>\n<p>35 DUnitX<br>\n35.1 Looking at Some Code<br>\n35.1.1 DUnit vs. DUnitX Features<br>\n35.2 DUnit vs. DUnitX<br>\n35.3 Summary<\/p>\n<p>36 FixInsight<br>\n36.1 Real World Data<\/p>\n<p>37 GExperts<br>\n37.1 Configuration<br>\n37.2 Editor Experts<br>\n37.3 Replace Components<br>\n37.4 GREP Search<br>\n37.5 GExperts Summary<\/p>\n<p>38 Homebrew Tools<br>\n38.1 Cycles Analyzer<br>\n38.1.1 Cycles Analyzer Code<br>\n38.1.2 Dependency Cycles in Components<br>\n38.1.3 Unit Dependencies: A Closer View<br>\n38.2 Map Explorer<br>\n38.3 Component Collector<br>\n38.3.1 Collecting Installed Components<br>\n38.3.2 Collecting the DFM Files List<br>\n38.3.3 Collect Component Instances<br>\n38.3.4 Producing the Aggregate Component Data<br>\n38.3.5 Putting Together the Pieces<br>\n38.4 Separating Wheat and Chaff<\/p>\n<p>39 MapFileStats<\/p>\n<p>40 MMX<br>\n40.1 Add Class<br>\n40.2 Add Field<br>\n40.3 Add Method<br>\n40.4 Sort Class<br>\n40.5 Synchronize Signatures<br>\n40.6 Swap Scopes<br>\n40.7 Unit Dependency Analyzer<br>\n40.8 Summary<\/p>\n<p>41 Peganza Products<br>\n41.1 Overview<br>\n41.2 Pascal Analyzer<br>\n41.3 Pascal Expert<br>\n41.4 Pascal Browser<\/p>\n<p>42 ProDelphi<br>\n42.1 Profiling Some Demo Code<br>\n42.1.1 Considering ExportDataSetToCSV<br>\n42.2 Profiling, in General<br>\n42.2.1 Why Profile, Why Optimize?<\/p>\n<p>43 TestInsight<\/p>\n<p>Bibliography<\/p>\n<p>Alphabetical Index<\/p>"}],
"keywords":[
]}