{
"id":28,
"url":"",
"guid":"6A39FCB8DA18EE118C5C32A5A9F17050",
"pagename":"Parallel-programming-with-OmniThreadLibrary.html",
"datalevel":8,
"dataversion":1,
"ispagetobuild":true,
"name":"Parallel programming with OmniThreadLibrary",
"lang":"en",
"pubdate":"20180206",
"thumb":"",
"isbn10":"",
"isbn13":"",
"website":"https:\/\/www.thedelphigeek.com\/2018\/02\/parallel-programming-with.html",
"cover":"",
"cover_100w":"",
"cover_150w":"",
"cover_200w":"",
"cover_300w":"",
"cover_400w":"",
"cover_500w":"",
"cover_100h":"",
"cover_200h":"",
"cover_300h":"",
"cover_400h":"",
"cover_500h":"",
"cover_100x100":"",
"cover_200x200":"",
"cover_300x300":"",
"cover_400x400":"",
"cover_500x500":"",
"cover_130x110":"",
"authors":[
{
"id":7,
"url":"",
"guid":"2213FCB8DA18EE118C5C32A5A9F17050",
"pagename":"Primoz-Gabrijelcic.html",
"datalevel":6,
"dataversion":1,
"ispagetobuild":true,
"name":""}],
"publishers":[
{
"id":6,
"url":"",
"guid":"9C24FDB8DA18EE118C5C32A5A9F17050",
"pagename":"Leanpub.html",
"datalevel":4,
"dataversion":1,
"ispagetobuild":true,
"label":"Leanpub"}],
"descriptions":[
{
"guid":"F639FCB8DA18EE118C5C32A5A9F17050",
"pagename":"",
"datalevel":3,
"dataversion":1,
"ispagetobuild":true,
"lang":"en",
"text":"Parallel programming is hard. Your best bet to a stable application is a good multithreading framework and for Delphi that means <A href=\"http:\/\/www.omnithreadlibrary.com\">OmniThreadLibrary<\/A>.\n\nThis book - which is, incidentally, written by the very author of the OmniThreadLibrary - walks you through different parts of the library. It gives an overview of low-level multithreading approach (programming with tasks), high-level approach (programming with abstractions) and describes various helper functions and data structures implemented in the library.\n\nThe book also walks you through multiple examples which demonstrate different aspects of multithreaded programming - from parallel execution of http requests to creation of database connection pools and multithreaded user interfaces."}],
"tocs":[
{
"guid":"283AFCB8DA18EE118C5C32A5A9F17050",
"pagename":"",
"datalevel":3,
"dataversion":1,
"ispagetobuild":true,
"lang":"en",
"text":"About me\nCredits\nIntroduction\nFormatting conventions\nLearn more\nRelease notes\n1. Introduction to multi-threading\n1.1 Multi-threading as a source of problems\n1.1.1 Reading and writing shared data\n1.1.2 Modifying shared data\n1.1.3 Writes masquerading as reads\n2. Introduction to OmniThreadLibrary\n2.1 Requirements\n2.2 License\n2.3 Installation\n2.3.1 Installing with GetIt\n2.3.2 Installing with Delphinus\n2.3.3 Installing design package\n2.4 Why use OmniThreadLibrary?\n2.5 Tasks vs. threads\n2.6 Locking vs. messaging\n2.7 Message loop required\n2.7.1 OmniThreadLibrary and console\n2.7.2 OmniThreadLibrary task started from another task\n2.7.3 OmniThreadLibrary task started from a TThread\n2.8 TOmniValue\n2.8.1 Data access\n2.8.2 Type testing\n2.8.3 Clearing the content\n2.8.4 Operators\n2.8.5 Using with generic types\n2.8.6 Array access\n2.8.7 Handling records\n2.8.8 Object ownership\n2.8.9 Working with TValue\n2.8.10 Low-level methods\n2.9 TOmniValueObj\n2.10 Fluent interfaces\n3. High-level multi-threading\n3.1 Introduction\n3.1.1 A life cycle of an abstraction\n3.1.2 Anonymous methods, procedures, and methods\n3.1.3 Pooling\n3.2 Blocking collection\n3.2.1 IOmniBlockingCollection\n3.2.2 Bulk import and export\n3.2.3 Throttling\n3.3 Task configuration\n3.4 Async\n3.4.1 Handling exceptions\n3.5 Async\/Await\n3.6 Future\n3.6.1 IOmniFuture<T> interface\n3.6.2 Completion detection\n3.6.3 Cancellation\n3.6.4 Handling exceptions\n3.6.5 Examples\n3.7 Join\n3.7.1 IOmniParallelJoin interface\n3.7.2 IOmniJoinState interface\n3.7.3 Cancellation\n3.7.4 Handling exceptions\n3.8 Parallel task\n3.8.1 IOmniParallelTask interface\n3.8.2 Example\n3.8.3 Handling exceptions\n3.8.4 Examples\n3.9 Background worker\n3.9.1 Basics\n3.9.2 IOmniBackgroundWorker interface\n3.9.3 Task initialization\n3.9.4 Work item configuration\n3.9.5 Work item interface\n3.9.6 Examples\n3.10 Pipeline\n3.10.1 Background\n3.10.2 Basics\n3.10.3 IOmniPipeline interface\n3.10.3.1 Example\n3.10.4 Generators, mutators, and aggregators\n3.10.5 Throttling\n3.10.6 Parallel stages\n3.10.7 Exceptions\n3.10.8 Examples\n3.11 Parallel for\n3.11.1 IOmniParallelSimpleLoop interface\n3.11.2 Iterating over an array\n3.11.3 Examples\n3.12 ForEach\n3.12.1 Cooperation\n3.12.2 Iterating over \u2026\n3.12.2.1 \u2026 Number ranges\n3.12.2.2 \u2026 Enumerable collections\n3.12.2.3 \u2026 Thread-safe enumerable collections\n3.12.2.4 \u2026 Blocking collections\n3.12.2.5 \u2026 Anything\n3.12.3 Providing external input\n3.12.4 IOmniParallelLoop interface\n3.12.5 Preserving output order\n3.12.6 Aggregation\n3.12.7 Cancellation\n3.12.8 Task initialization and finalization\n3.12.9 Handling exceptions\n3.12.10 Examples\n3.13 Fork\/Join\n3.13.1 IOmniForkJoin interface\n3.13.2 IOmniCompute interface\n3.13.3 IOmniCompute<T> interface\n3.13.4 Exceptions\n3.13.5 Examples\n3.14 Map\n3.14.1 IOmniParallelMapper<T1,T2> interface\n3.15 Timed task\n3.15.1 IOmniTimedTask interface\n4. Low-level multi-threading\n4.1 Low-level for the impatient\n4.2 Four ways to create a task\n4.3 IOmniTaskControl and IOmniTask interfaces\n4.4 Task controller needs an owner\n4.5 Communication subsystem\n4.6 Processor groups and NUMA nodes\n4.7 Thread pooling\n4.7.1 Execution flow\n4.7.2 IOmniThreadPool interface\n4.7.3 Task exit code\n4.7.4 Monitoring thread pool operations\n4.7.5 Processor groups and NUMA nodes\n4.8 Lock-free collections\n4.8.1 Bounded Stack\n4.8.2 Bounded queue\n4.8.3 Message queue\n4.8.4 Dynamic queue\n4.8.5 Observing lock-free collections\n4.8.5.1 Examples\n4.8.6 Benchmarks\n4.9 Event monitor\n4.10 Simple tasks\n4.10.1 Name\n4.10.2 UniqueID\n4.10.3 Parameters\n4.10.4 Termination\n4.10.5 ExitCode\n4.10.6 Exceptions\n4.10.7 Sending messages to a task\n4.10.8 Receiving messages from a task\n4.10.9 ChainTo\n4.10.10 Join \/ Leave\n4.10.11 MonitorWith \/ RemoveMonitor\n4.10.12 Enforced\n4.10.13 Unobserved\n4.10.14 Cancellation token \/ CancelWith\n4.10.15 Lock \/ WithLock\n4.10.16 WithCounter\n4.10.17 SetPriority\n4.10.18 SetQueueSize\n4.11 TOmniWorker tasks\n4.11.1 WaitForInit\n4.11.2 Task\n4.11.3 Receiving messages\n4.11.4 RegisterComm\n4.11.5 Invoke\n4.11.6 Windows message & APC processing\n4.11.7 Timers\n4.11.8 TerminateWhen\n4.11.9 UserData\n4.12 Task groups\n4.13 IOmniTask interface\n4.13.1 Name and ID\n4.13.2 Parameters\n4.13.3 Termination\n4.13.4 Exit status\n4.13.5 Exceptions\n4.13.6 Communication\n4.13.7 Timers\n4.13.8 RegisterWaitObject\n4.13.9 CancellationToken\n4.13.10 Lock\n4.13.11 Counter\n4.13.12 Processor groups and NUMA nodes\n4.13.13 Internal and obsolete functions\n5. Synchronization\n5.1 Critical sections\n5.1.1 IOmniCriticalSection\n5.1.2 TOmniCS\n5.1.3 Locked<T>\n5.1.3.1 Why not use TMonitor?\n5.2 TOmniMREW\n5.3 Cancellation token\n5.4 Waitable value\n5.5 Inverse semaphore\n5.6 Initialization\n5.6.1 Pessimistic initialization\n5.6.2 Optimistic initialization\n5.7 TWaitFor\n5.8 TOmniLockManager<K>\n5.9 TOmniSingleThreadUseChecker\n6. Miscellaneous\n6.1 TOmniTwoWayChannel\n6.2 TOmniValueContainer\n6.3 TOmniCounter\n6.4 TOmniAlignedInt32 and TOmniAlignedInt64\n6.5 TOmniRecordWrapper\n6.6 TOmniRecord\n6.7 IOmniAutoDestroyObject\n6.8 IOmniIntegerSet\n6.9 Environment\n6.9.1 IOmniAffinity\n7. How-to\n7.1 Background file scanning\n7.2 Web download and database storage\n7.3 Parallel for with synchronized output\n7.4 Using taskIndex and task initializer in parallel for\n7.5 Background worker and list partitioning\n7.6 Parallel data production\n7.7 Building a connection pool\n7.7.1 From theory to practice\n7.7.2 Running the demo\n7.8 QuickSort and parallel max\n7.8.1 QuickSort\n7.8.2 Parallel max\n7.9 Parallel search in a tree\n7.10 Multiple workers with multiple frames\n7.10.1 The worker\n7.10.2 The frame\n7.10.3 The form\n7.11 OmniThreadLibrary and databases\n7.11.1 Database model\n7.11.2 Frame and worker\n7.11.2.1 Connecting to the database\n7.11.2.2 Retrieving the data\n7.11.3 Main program\n7.12 OmniThreadLibrary and COM\/OLE\n7.13 Using a message queue with a TThread worker\n7.13.1 Sending data from multiple producers to a single worker\n7.13.1.1 Initialization and cleanup\n7.13.1.2 Sending data to the worker\n7.13.1.3 Receiving the data\n7.13.2 Sending data from a worker to a form\n7.13.2.1 Initialization and cleanup\n7.13.2.2 Sending data to the form\n7.13.2.3 Receiving the data\nA. Units\nB. Demo applications\nC. Examples\nD. Hooking into OmniThreadLibrary\nException notifications\nThread notifications\nPool notifications\nE. ForEach internals\nSource provider\nData manager\nLocal queue\nOutput ordering\nF. Hyperlinks\nNotes"}],
"keywords":[
]}