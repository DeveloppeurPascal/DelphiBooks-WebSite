{
"id":136,
"guid":"CA8AAB38920C483DB2E51457E4F9F604",
"pagename":"Delphi-in-all-its-glory.html",
"datalevel":7,
"dataversion":1,
"name":"Delphi in all its glory",
"lang":"en",
"pubdate":"20230329",
"isbn13":"9798387412141",
"website":"https:\/\/gabrielmoraru.com\/delphi-in-all-its-glory\/",
"authors":[
{
"id":51,
"guid":"A08AFCB8DA18EE118C5C32A5A9F17050",
"pagename":"Gabriel-Moraru.html",
"datalevel":7,
"dataversion":1}],
"publishers":[
],
"descriptions":[
{
"guid":"CD419D301AAF4E57A195B3D122F12932",
"pagename":"",
"datalevel":3,
"dataversion":1,
"lang":"en",
"text":"<p>For whom is this book for?<\/p>\r\n<p>This book is for everyone who wants to learn how to build fast, good-looking, stable applications. It doesn't matter if you never wrote a line of code, we will start from ground zero, but we will not stop until we reach the most advanced topics.<\/p>\r\n<p>What is Delphi?<\/p>\r\n<p>Delphi is a modern multi-purpose programming language. With Delphi, we can create cool looking graphic applications for Windows, Mac, Linux and Android. Take a look at \"Let there be styles\" chapter to see Delphi programs in all their beauty.<\/p>\r\n<p>Delphi is fast, Delphi is easy to learn (seriously), Delphi is free (for personal use with its Community Edition).<\/p>"}],
"tocs":[
{
"guid":"884ABB5E68994E3CAD5FD84EC27A87A8",
"pagename":"",
"datalevel":3,
"dataversion":1,
"lang":"en",
"text":"<p>1. Overview . . . . . 2<\/p>\r\n<ul>\r\n<li>For whom is this book for? . . . . . 2<\/li>\r\n<li>What is Delphi? . . . . . 2<\/li>\r\n<li>What will you learn from this book? . . . . . 2<\/li>\r\n<li>Book layout . . . . . 3<\/li>\r\n<li>Who am I? . . . . . 3<\/li>\r\n<li>How is this book written? . . . . . 4<\/li>\r\n<li>This book is eco-friendly . . . . . 4<\/li>\r\n<li>Pre-requisites for this book . . . . . 4<\/li>\r\n<li>Let\u2019s start . . . . . 4<\/li><\/ul>\r\n<p>2. Table of content . . . . . 5<\/p>\r\n<p>3. What is Delphi? . . . . . 24<\/p>\r\n<ul>\r\n<li>Delphi is RAD . . . . . 24<\/li>\r\n<li>Delphi is general-purpose . . . . . 24<\/li>\r\n<li>Delphi has deep roots . . . . . 24<\/li>\r\n<li>A bit of history . . . . . 25<\/li>\r\n<li>Delphi = GUI . . . . . 26<\/li>\r\n<li>What is the VCL? . . . . . 26<\/li>\r\n<li>What is RAD Studio? . . . . . 26<\/li>\r\n<li>An IDE with multiple personalities. How does it work? . . . . . 27<\/li>\r\n<li>A complete IDE . . . . . 28<\/li>\r\n<li>Mature and polished . . . . . 28<\/li>\r\n<li>But, it must be expensive... right? . . . . . 29<\/li>\r\n<li>What can we build right out of the box, with Delphi? . . . . . 30<\/li>\r\n<li>Advantages of Delphi applications . . . . . 32<\/li>\r\n<li>Where can we use Delphi? . . . . . 34<\/li>\r\n<li>Where can\u2019t we use Delphi? . . . . . 35<\/li>\r\n<li>Delphi\u2019s productivity . . . . . 35<\/li>\r\n<li>Famous programs built with Delphi . . . . . 36<\/li>\r\n<li>Summary . . . . . 36<\/li><\/ul>\r\n<p>4. Delphi today . . . . . 37<\/p>\r\n<ul>\r\n<li>Popularity . . . . . 37<\/li>\r\n<li>About Evil, Darth Vader and... Bill Gates . . . . . 38<\/li>\r\n<li>Availability of libraries . . . . . 39<\/li>\r\n<li>A brighter future . . . . . 39<\/li>\r\n<li>Tiobe Index . . . . . 40<\/li>\r\n<li>Summary . . . . . 40<\/li><\/ul>\r\n<p>5. An overview of the Delphi language . . . . . 42<\/p>\r\n<ul>\r\n<li>Clarity . . . . . 42<\/li>\r\n<li>A strongly typed language . . . . . 42<\/li>\r\n<li>Well designed . . . . . 42<\/li>\r\n<li>One string to rule them all . . . . . 43<\/li>\r\n<li>Not open-source . . . . . 43<\/li>\r\n<li>Fastest compiler . . . . . 45<\/li>\r\n<li>Better error messages . . . . . 45<\/li>\r\n<li>The compiler is here to help us . . . . . 46<\/li>\r\n<li>No more pointers . . . . . 46<\/li>\r\n<li>ASM in the mix . . . . . 46<\/li>\r\n<li>Damn fast . . . . . 46<\/li>\r\n<li>Compared to Julia . . . . . 47<\/li>\r\n<li>What kind of applications can we build with Delphi? . . . . . 47<\/li>\r\n<li>Why building apps is so easy with Delphi? . . . . . 48<\/li>\r\n<li>Delphi is WYSIWYG . . . . . 48<\/li>\r\n<li>Quick mockups . . . . . 48<\/li>\r\n<li>The VCL framework . . . . . 49<\/li>\r\n<li>Low code \/ no code . . . . . 49<\/li>\r\n<li>Portable code . . . . . 50<\/li>\r\n<li>Native look . . . . . 50<\/li>\r\n<li>Ready for the future . . . . . 50<\/li>\r\n<li>The never-ending story . . . . . 51<\/li>\r\n<li>Reminder . . . . . 51<\/li><\/ul>\r\n<p>6. Delphi\u2019s brothers . . . . . 52<\/p>\r\n<ul>\r\n<li>Lazarus \/ FPC . . . . . 52<\/li>\r\n<li>The \u201CBurning Monkey\u201D . . . . . 54<\/li>\r\n<li>A bit of history . . . . . 54<\/li>\r\n<li>Firemoneky = VCL on steroids . . . . . 55<\/li>\r\n<li>Disadvantages of FMX . . . . . 55<\/li>\r\n<li>Converting a VCL project to FireMonkey . . . . . 56<\/li>\r\n<li>Delphi\u2019s cousin . . . . . 57<\/li>\r\n<li>Summary . . . . . 57<\/li><\/ul>\r\n<p>7. Installing Delphi . . . . . 58<\/p>\r\n<ul>\r\n<li>ISO installer . . . . . 58<\/li>\r\n<li>The installation folder . . . . . 58<\/li>\r\n<li>Delphi sample projects . . . . . 62<\/li>\r\n<li>Delphi version info . . . . . 62<\/li>\r\n<li>Known bugs . . . . . 62<\/li>\r\n<li>Updates . . . . . 62<\/li>\r\n<li>We are done . . . . . 63<\/li><\/ul>\r\n<p>8. Let\u2019s get started . . . . . 64<\/p>\r\n<ul>\r\n<li>Anatomy of a Delphi Project . . . . . 64<\/li>\r\n<li>The Project Manager . . . . . 64<\/li>\r\n<li>Project Options . . . . . 66<\/li>\r\n<li>The DProj: DPR\u2019s little brother . . . . . 71<\/li>\r\n<li>Anatomy of a Delphi unit . . . . . 72<\/li><\/ul>\r\n<p>9. IDE this... IDE that... . . . . . 76<\/p>\r\n<ul>\r\n<li>The main menu . . . . . 77<\/li>\r\n<li>File . . . . . 77<\/li>\r\n<li>Edit . . . . . 77<\/li>\r\n<li>Search . . . . . 77<\/li>\r\n<li>Refactor . . . . . 78<\/li>\r\n<li>Run . . . . . 78<\/li>\r\n<li>GExperts and CnPack . . . . . 78<\/li>\r\n<li>Project . . . . . 78<\/li>\r\n<li>The main components of the IDE . . . . . 80<\/li>\r\n<li>The Project Manager . . . . . 80<\/li>\r\n<li>The Component Palette . . . . . 80<\/li>\r\n<li>The Object Inspector . . . . . 80<\/li>\r\n<li>The Messages window . . . . . 80<\/li>\r\n<li>Form designer . . . . . 80<\/li>\r\n<li>Customizing the IDE . . . . . 81<\/li>\r\n<li>The Code Editor . . . . . 82<\/li>\r\n<li>Code insights [1] . . . . . 82<\/li>\r\n<li>Code insights [2] . . . . . 82<\/li>\r\n<li>Indent a block of code . . . . . 83<\/li>\r\n<li>Easily re-order lines code . . . . . 83<\/li>\r\n<li>Auto-fix typos . . . . . 83<\/li>\r\n<li>Code Editor useful keyboard shortcuts . . . . . 83<\/li>\r\n<li>The Form Designer . . . . . 84<\/li>\r\n<li>Common IDE shortcuts . . . . . 85<\/li>\r\n<li>Third party IDE plugins for Delphi . . . . . 86<\/li>\r\n<li>DDevExtensions . . . . . 86<\/li>\r\n<li>CnPack . . . . . 87<\/li>\r\n<li>GExperts . . . . . 91<\/li>\r\n<li>We can build our own plugins . . . . . 91<\/li>\r\n<li>Plugin management . . . . . 92<\/li><\/ul>\r\n<p>10. Our first Delphi application . . . . . 93<\/p>\r\n<ul>\r\n<li>Smallest Delphi application . . . . . 93<\/li>\r\n<li>Let\u2019s start . . . . . 93<\/li>\r\n<li>Form = PAS + DFM . . . . . 98<\/li><\/ul>\r\n<p>11. A crash course in the Delphi language . . . . . 99<\/p>\r\n<ul>\r\n<li>If you already know C++ . . . . . 99<\/li>\r\n<li>A typical Delphi piece of code . . . . . 100<\/li>\r\n<li>Comments . . . . . 101<\/li>\r\n<li>Variables . . . . . 101<\/li>\r\n<li>What is a variable? . . . . . 101<\/li>\r\n<li>What are data types? . . . . . 101<\/li>\r\n<li>Declaring variables . . . . . 102<\/li>\r\n<li>General naming conventions in Delphi . . . . . 103<\/li>\r\n<li>Naming variables . . . . . 104<\/li>\r\n<li>Global versus local variables . . . . . 105<\/li>\r\n<li>Variable initialization . . . . . 106<\/li>\r\n<li>Assigning values to a variable . . . . . 107<\/li>\r\n<li>Constants . . . . . 108<\/li>\r\n<li>Arithmetic operators . . . . . 109<\/li>\r\n<li>How do computers store numbers in their memory? . . . . . 110<\/li>\r\n<li>Memory Cells . . . . . 110<\/li>\r\n<li>Data types . . . . . 113<\/li>\r\n<li>Primitive Data Types . . . . . 114<\/li>\r\n<li>Managed Data Types . . . . . 115<\/li>\r\n<li>Delphi is \u201Cstrong typed\u201D . . . . . 116<\/li>\r\n<li>Boolean data type . . . . . 117<\/li>\r\n<li>Integer data type . . . . . 117<\/li>\r\n<li>Strings . . . . . 119<\/li>\r\n<li>Advanced topics . . . . . 125<\/li>\r\n<li>Enumerations . . . . . 126<\/li>\r\n<li>Subranges . . . . . 127<\/li>\r\n<li>Real numbers . . . . . 127<\/li>\r\n<li>Arrays . . . . . 130<\/li>\r\n<li>The size of a variable . . . . . 137<\/li>\r\n<li>Defining our own data types . . . . . 139<\/li>\r\n<li>Routines . . . . . 140<\/li>\r\n<li>1. Compartmentalizing your code . . . . . 140<\/li>\r\n<li>2. Reusing your code . . . . . 141<\/li>\r\n<li>Procedures . . . . . 142<\/li>\r\n<li>Functions . . . . . 143<\/li>\r\n<li>Good practice . . . . . 149<\/li>\r\n<li>Statement separator . . . . . 149<\/li>\r\n<li>How does a computer program work? . . . . . 150<\/li>\r\n<li>Displaying a message . . . . . 150<\/li>\r\n<li>Records . . . . . 151<\/li>\r\n<li>Assigning records . . . . . 152<\/li>\r\n<li>Field initialization . . . . . 155<\/li>\r\n<li>Advanced topics . . . . . 155<\/li>\r\n<li>With . . . . . 156<\/li>\r\n<li>FOR loops . . . . . 157<\/li>\r\n<li>While . . . . . 159<\/li>\r\n<li>Repeat\/Until . . . . . 160<\/li>\r\n<li>Nested routines . . . . . 160<\/li>\r\n<li>Function overloading . . . . . 161<\/li>\r\n<li>Parameters of a routine . . . . . 161<\/li>\r\n<li>Open array parameters . . . . . 163<\/li>\r\n<li>Not all parameters are created equal . . . . . 164<\/li>\r\n<li>By reference . . . . . 164<\/li>\r\n<li>By value . . . . . 164<\/li>\r\n<li>By constant value (fastest) . . . . . 165<\/li>\r\n<li>By constant reference . . . . . 165<\/li>\r\n<li>Out parameters . . . . . 166<\/li>\r\n<li>Default parameters . . . . . 166<\/li>\r\n<li>Playing more with parameters of a routine . . . . . 167<\/li><\/ul>\r\n<p>12. Classes and objects . . . . . 171<\/p>\r\n<ul>\r\n<li>Why objects? . . . . . 171<\/li>\r\n<li>An object . . . . . 171<\/li>\r\n<li>Objects vs classes . . . . . 172<\/li>\r\n<li>Naming conventions . . . . . 172<\/li>\r\n<li>Instantiation . . . . . 172<\/li>\r\n<li>Extensibility . . . . . 173<\/li>\r\n<li>Constructors . . . . . 173<\/li>\r\n<li>Let's build our own class: . . . . . 174<\/li>\r\n<li>Inherited . . . . . 174<\/li>\r\n<li>Destructors . . . . . 175<\/li>\r\n<li>Try\/Finally . . . . . 175<\/li>\r\n<li>Super-duper important . . . . . 176<\/li>\r\n<li>Special cases . . . . . 176<\/li>\r\n<li>Fields . . . . . 178<\/li>\r\n<li>Properties . . . . . 178<\/li>\r\n<li>Read-only properties . . . . . 180<\/li>\r\n<li>Recap . . . . . 181<\/li>\r\n<li>Published properties . . . . . 181<\/li>\r\n<li>Default . . . . . 182<\/li>\r\n<li>Manual memory management for objects . . . . . 182<\/li>\r\n<li>Pointers . . . . . 187<\/li>\r\n<li>Typed vs untyped pointers . . . . . 188<\/li>\r\n<li>Dereferencing a pointer . . . . . 188<\/li>\r\n<li>Assigning pointers . . . . . 189<\/li>\r\n<li>References . . . . . 192<\/li>\r\n<li>Dangling references . . . . . 194<\/li>\r\n<li>Assigning an object to another object . . . . . 195<\/li>\r\n<li>Objects \u2013 A real world example . . . . . 198<\/li>\r\n<li>Inheritance, polymorphism, and typecasting . . . . . 199<\/li>\r\n<li>The inheritance chain . . . . . 199<\/li>\r\n<li>Typecasting . . . . . 201<\/li>\r\n<li>The hard typecast . . . . . 202<\/li>\r\n<li>The 'as' typecast . . . . . 203<\/li>\r\n<li>The 'is' operator . . . . . 204<\/li>\r\n<li>Invalid typecasts . . . . . 205<\/li>\r\n<li>More invalid typecasts . . . . . 205<\/li>\r\n<li>RTTI alternative . . . . . 206<\/li>\r\n<li>Methods . . . . . 207<\/li>\r\n<li>Method binding . . . . . 207<\/li>\r\n<li>Speed . . . . . 208<\/li>\r\n<li>Static methods . . . . . 208<\/li>\r\n<li>Overriding methods \/ Polymorphic behavior . . . . . 209<\/li>\r\n<li>Polymorphism . . . . . 211<\/li>\r\n<li>Hiding vs overriding . . . . . 212<\/li>\r\n<li>VMT . . . . . 214<\/li>\r\n<li>Overloading methods . . . . . 215<\/li>\r\n<li>Recap for polymorphism . . . . . 217<\/li>\r\n<li>Another experiment . . . . . 217<\/li>\r\n<li>Declaring multiple constructors with the same name . . . . . 218<\/li>\r\n<li>Keywords recap . . . . . 220<\/li>\r\n<li>Methods - Advanced topics . . . . . 221<\/li>\r\n<li>Class methods . . . . . 221<\/li>\r\n<li>Concrete example . . . . . 221<\/li>\r\n<li>Let's write a better example . . . . . 223<\/li>\r\n<li>Class fields . . . . . 224<\/li>\r\n<li>Putting class fields to a good use - Singleton class . . . . . 225<\/li>\r\n<li>One more example . . . . . 225<\/li>\r\n<li>Predefined class methods in TObject . . . . . 226<\/li>\r\n<li>Abstract methods . . . . . 227<\/li>\r\n<li>Abstract classes . . . . . 230<\/li>\r\n<li>Generics . . . . . 230<\/li>\r\n<li>Creating a generic class . . . . . 232<\/li><\/ul>\r\n<p>13. Forms . . . . . 234<\/p>\r\n<ul>\r\n<li>PAS + DFM = Form . . . . . 234<\/li>\r\n<li>Auto-created forms . . . . . 236<\/li>\r\n<li>The main form . . . . . 236<\/li>\r\n<li>Secondary forms . . . . . 237<\/li>\r\n<li>Stay on top . . . . . 240<\/li>\r\n<li>The \u201CApplication\u201D object . . . . . 240<\/li>\r\n<li>Showing a new created form . . . . . 241<\/li>\r\n<li>The owner of a form . . . . . 241<\/li>\r\n<li>Application as owner . . . . . 241<\/li>\r\n<li>Form as owner . . . . . 242<\/li>\r\n<li>Nil as owner (no owner) . . . . . 242<\/li>\r\n<li>Form initialization . . . . . 242<\/li>\r\n<li>Closing a form . . . . . 246<\/li>\r\n<li>Several ways to close a form . . . . . 247<\/li>\r\n<li>Release versus Close . . . . . 248<\/li>\r\n<li>About GUI Applications . . . . . 249<\/li>\r\n<li>So, why do we need GUIs? . . . . . 249<\/li>\r\n<li>Save GUI state to file . . . . . 258<\/li>\r\n<li>User selectable styles . . . . . 258<\/li>\r\n<li>Summary . . . . . 259<\/li><\/ul>\r\n<p>14. Visual components . . . . . 260<\/p>\r\n<ul>\r\n<li>Parenting and Ownership . . . . . 261<\/li>\r\n<li>Parenting and modularization . . . . . 262<\/li>\r\n<li>Ownership vs Parenting . . . . . 264<\/li>\r\n<li>Properties of a component . . . . . 264<\/li>\r\n<li>Building our own visual component . . . . . 265<\/li>\r\n<li>Event handlers . . . . . 267<\/li>\r\n<li>The ubiquitous Sender parameter . . . . . 270<\/li>\r\n<li>Most used visual components . . . . . 271<\/li>\r\n<li>TLabel . . . . . 272<\/li>\r\n<li>TButton . . . . . 272<\/li>\r\n<li>TPanel . . . . . 272<\/li>\r\n<li>TRadioButton . . . . . 273<\/li>\r\n<li>TCheckBox . . . . . 273<\/li>\r\n<li>TImage . . . . . 273<\/li>\r\n<li>TEdit . . . . . 274<\/li>\r\n<li>TMemo . . . . . 274<\/li>\r\n<li>TRichEdit . . . . . 274<\/li>\r\n<li>TSpinEdit . . . . . 275<\/li>\r\n<li>Visual Components (advanced) . . . . . 275<\/li>\r\n<li>TTrayIcon . . . . . 275<\/li>\r\n<li>TFlowPanel . . . . . 278<\/li>\r\n<li>TGridPanel . . . . . 280<\/li>\r\n<li>Actions \/ TActionList . . . . . 282<\/li>\r\n<li>TActionManager . . . . . 289<\/li><\/ul>\r\n<p>15. The Delphi compiler . . . . . 297<\/p>\r\n<ul>\r\n<li>What is a compiler? What is an interpreter? . . . . . 297<\/li>\r\n<li>A reliable compiler . . . . . 297<\/li>\r\n<li>The toolchain . . . . . 298<\/li>\r\n<li>Executable size . . . . . 298<\/li>\r\n<li>Compiler speed . . . . . 299<\/li>\r\n<li>Improve compiler\u2019s speed . . . . . 299<\/li>\r\n<li>From Pas to Exe . . . . . 301<\/li>\r\n<li>The compilation order . . . . . 302<\/li>\r\n<li>Running the program . . . . . 303<\/li>\r\n<li>DCUs . . . . . 303<\/li>\r\n<li>The linker . . . . . 303<\/li>\r\n<li>Compile vs Build . . . . . 304<\/li>\r\n<li>Debug vs Release DCUs . . . . . 304<\/li>\r\n<li>Release-mode . . . . . 304<\/li>\r\n<li>Debug-mode . . . . . 305<\/li>\r\n<li>The Debug information . . . . . 305<\/li><\/ul>\r\n<p>16. Libraries . . . . . 307<\/p>\r\n<ul>\r\n<li>Library architecture . . . . . 307<\/li>\r\n<li>It is all about aliens and pyramids . . . . . 309<\/li>\r\n<li>The files of a library . . . . . 310<\/li>\r\n<li>DPK . . . . . 310<\/li>\r\n<li>GroupProj . . . . . 310<\/li>\r\n<li>BPL . . . . . 311<\/li>\r\n<li>Using libraries in our projects . . . . . 311<\/li>\r\n<li>The RTL library . . . . . 312<\/li>\r\n<li>The VCL library . . . . . 312<\/li>\r\n<li>Library paths . . . . . 313<\/li>\r\n<li>Environment variables . . . . . 313<\/li>\r\n<li>The \u201CLibrary\u201D settings . . . . . 313<\/li>\r\n<li>The \u201CLibrary path\u201D field . . . . . 315<\/li>\r\n<li>The \u201CPackage\/DCP\/HPP output directory\u201D fields . . . . . 318<\/li>\r\n<li>The \u201CBrowsing path\u201D field . . . . . 318<\/li>\r\n<li>The \u201CDebug DCU path\u201D field . . . . . 320<\/li>\r\n<li>Debugger Source Path . . . . . 320<\/li>\r\n<li>Precompiled files . . . . . 320<\/li>\r\n<li>The \u201CUse debug DCUs\u201D field . . . . . 321<\/li>\r\n<li>Precompiling our own files . . . . . 322<\/li>\r\n<li>The \u201CDebug source path\u201D field . . . . . 323<\/li>\r\n<li>Project Paths . . . . . 325<\/li>\r\n<li>How to install a library? . . . . . 326<\/li>\r\n<li>Installing a library . . . . . 326<\/li>\r\n<li>Adding library\u2019s folder to the \u201CSearch path\u201D . . . . . 327<\/li>\r\n<li>Installers . . . . . 329<\/li>\r\n<li>Installing libraries via GetIt . . . . . 329<\/li>\r\n<li>How to uninstall a library from Delphi . . . . . 331<\/li>\r\n<li>Runtime\/Designtime libraries . . . . . 332<\/li>\r\n<li>Run-time libraries . . . . . 332<\/li>\r\n<li>Design time libraries . . . . . 332<\/li>\r\n<li>Design time vs Run time . . . . . 333<\/li>\r\n<li>How to use a library in our projects? . . . . . 334<\/li>\r\n<li>About libraries and licenses . . . . . 335<\/li>\r\n<li>Discussions . . . . . 337<\/li>\r\n<li>Conclusions . . . . . 338<\/li>\r\n<li>More details . . . . . 338<\/li>\r\n<li>Dynamic Link Libraries (BPLs) in Delphi . . . . . 338<\/li>\r\n<li>Link with runtime packages . . . . . 339<\/li>\r\n<li>Separating Libraries from Projects . . . . . 341<\/li>\r\n<li>The libraries are \u201Cglobal\u201D . . . . . 341<\/li>\r\n<li>Debugging 3rd party libraries . . . . . 342<\/li>\r\n<li>Using C\/++ libraries in Delphi . . . . . 343<\/li>\r\n<li>Popular libraries . . . . . 345<\/li>\r\n<li>FastMM4 . . . . . 345<\/li>\r\n<li>Graphics32 . . . . . 346<\/li>\r\n<li>Delphi LightSaber . . . . . 346<\/li>\r\n<li>Jedi . . . . . 346<\/li>\r\n<li>LightSaber . . . . . 347<\/li>\r\n<li>Freeware . . . . . 347<\/li>\r\n<li>Sub-libraries . . . . . 348<\/li>\r\n<li>LightSaber Core . . . . . 349<\/li>\r\n<li>LightSaber Log . . . . . 351<\/li>\r\n<li>LightSaber Common . . . . . 352<\/li>\r\n<li>LightSaber Internet . . . . . 353<\/li>\r\n<li>Filename convention used in Delphi LightSaber . . . . . 354<\/li>\r\n<li>Proteus . . . . . 354<\/li>\r\n<li>What is Proteus? . . . . . 354<\/li>\r\n<li>What can Proteus do for us? . . . . . 355<\/li>\r\n<li>How to use it? . . . . . 355<\/li>\r\n<li>Proteus details . . . . . 357<\/li>\r\n<li>Setting up your app . . . . . 360<\/li>\r\n<li>Advanced topics . . . . . 362<\/li>\r\n<li>Certificate ID . . . . . 364<\/li>\r\n<li>Active certificate . . . . . 365<\/li><\/ul>\r\n<p>17. The debugger . . . . . 366<\/p>\r\n<ul>\r\n<li>What is a debugger? . . . . . 366<\/li>\r\n<li>Preparing our project for debugging . . . . . 366<\/li>\r\n<li>Stacks . . . . . 366<\/li>\r\n<li>Configurations . . . . . 368<\/li>\r\n<li>The \u201CCompiling\u201D page . . . . . 369<\/li>\r\n<li>Other settings . . . . . 371<\/li>\r\n<li>A picture is worth a thousand words . . . . . 371<\/li>\r\n<li>The \u201CLinking\u201D page . . . . . 373<\/li>\r\n<li>Debugger Source Path . . . . . 374<\/li>\r\n<li>Breakpoints . . . . . 375<\/li>\r\n<li>Breakpoint properties . . . . . 377<\/li>\r\n<li>Relocate the execution point manually . . . . . 378<\/li>\r\n<li>Finally, ready to debug . . . . . 379<\/li>\r\n<li>Starting the program under the debugger . . . . . 379<\/li>\r\n<li>Debugging from a crash point . . . . . 380<\/li>\r\n<li>Cannot debug? . . . . . 383<\/li>\r\n<li>Fun stuff to do during debugging . . . . . 384<\/li>\r\n<li>Hint for geeks . . . . . 386<\/li>\r\n<li>Debugging cheat sheet . . . . . 387<\/li><\/ul>\r\n<p>18. Remote debugging . . . . . 389<\/p>\r\n<ul>\r\n<li>How does it work? . . . . . 389<\/li>\r\n<li>Install PAserver (on the remote machine) . . . . . 390<\/li>\r\n<li>Run PAServer (on the remote machine) . . . . . 390<\/li>\r\n<li>Configure the environment (locally) . . . . . 391<\/li>\r\n<li>Assign a Connection Profile to the Delphi project . . . . . 394<\/li>\r\n<li>Choose which files to deploy . . . . . 396<\/li>\r\n<li>Deploying the files manually . . . . . 396<\/li>\r\n<li>Start debugging . . . . . 396<\/li>\r\n<li>Stability . . . . . 397<\/li><\/ul>\r\n<p>19. Automatic bug reporting . . . . . 399<\/p>\r\n<ul>\r\n<li>MadShi MadExcept . . . . . 400<\/li>\r\n<li>EurekaLog . . . . . 403<\/li><\/ul>\r\n<p>20. Advanced debugging techniques . . . . . 405<\/p>\r\n<ul>\r\n<li>How to debug your components\/the IDE? . . . . . 405<\/li>\r\n<li>Method 1: Attach to process . . . . . 405<\/li>\r\n<li>Method 2: Debug with \u201CRun -> Load process\u201D. 406<\/li>\r\n<li>Method 3: External tools . . . . . 410<\/li>\r\n<li>Method 4: Start Delphi in \u201Csafe\u201D mode . . . . . 411<\/li>\r\n<li>Stupid Windows 10 . . . . . 411<\/li><\/ul>\r\n<p>21. Speed up your program . . . . . 412<\/p>\r\n<ul>\r\n<li>Profiling your program . . . . . 413<\/li>\r\n<li>Home-brewed method (as cheap as the home-made beer) . . . . . 413<\/li>\r\n<li>Third party profilers (aka non-free) . . . . . 415<\/li>\r\n<li>Improving the speed . . . . . 416<\/li>\r\n<li>Record field alignment . . . . . 416<\/li>\r\n<li>CPU Optimization . . . . . 419<\/li>\r\n<li>Compared to Julia . . . . . 420<\/li><\/ul>\r\n<p>22. Compiler! Please save my ass! . . . . . 426<\/p>\r\n<ul>\r\n<li>Overflow checking . . . . . 427<\/li>\r\n<li>IO checking . . . . . 428<\/li>\r\n<li>Range Checking . . . . . 428<\/li>\r\n<li>Enabling Runtime Error Checking . . . . . 428<\/li>\r\n<li>Assertions . . . . . 429<\/li>\r\n<li>Nothing comes for free . . . . . 431<\/li><\/ul>\r\n<p>23. Memory management . . . . . 432<\/p>\r\n<ul>\r\n<li>FastMM . . . . . 432<\/li>\r\n<li>1. Dramatic speed increase for memory-bound operations . . . . . 432<\/li>\r\n<li>2. Prevents memory fragmentation . . . . . 432<\/li>\r\n<li>3. Better memory sharing . . . . . 433<\/li>\r\n<li>4. Safer code . . . . . 433<\/li>\r\n<li>5. No more access violations . . . . . 436<\/li>\r\n<li>Switching FastMM to Full Debug Mode . . . . . 437<\/li>\r\n<li>How to read a FastMM leak report? . . . . . 437<\/li>\r\n<li>The summary . . . . . 439<\/li>\r\n<li>Leaked blocks . . . . . 439<\/li>\r\n<li>Advanced topics . . . . . 442<\/li>\r\n<li>You create it, you kill it . . . . . 442<\/li>\r\n<li>Memory ownership . . . . . 442<\/li>\r\n<li>Dangling references . . . . . 443<\/li>\r\n<li>Alice loses her preferred book . . . . . 443<\/li>\r\n<li>Getting our dirty paws on a dangling reference . . . . . 444<\/li>\r\n<li>The root of all evil . . . . . 446<\/li>\r\n<li>There are even worst scenarios . . . . . 447<\/li>\r\n<li>Do some noise . . . . . 447<\/li>\r\n<li>Bruce Willis (and FastMM) saves the day... again! . . . . . 449<\/li>\r\n<li>Garbage collectors . . . . . 450<\/li>\r\n<li>About ownership . . . . . 450<\/li>\r\n<li>Passing the ownership around . . . . . 451<\/li>\r\n<li>Summary . . . . . 453<\/li><\/ul>\r\n<p>24. Exceptions . . . . . 454<\/p>\r\n<ul>\r\n<li>Exception Handling . . . . . 456<\/li>\r\n<li>Let\u2019s do the \u201CWhat this code does\u201D game . . . . . 459<\/li>\r\n<li>Amateur mistake . . . . . 461<\/li>\r\n<li>Keep it real . . . . . 463<\/li>\r\n<li>Spit, don't swallow . . . . . 463<\/li>\r\n<li>Good boy, Debugger! . . . . . 464<\/li>\r\n<li>Ignoring exceptions during debugging . . . . . 465<\/li>\r\n<li>Try\/Finally vs Try\/Except . . . . . 467<\/li>\r\n<li>Raising exceptions . . . . . 469<\/li><\/ul>\r\n<p>25. Windows Messages in Delphi . . . . . 471<\/p>\r\n<ul>\r\n<li>The Windows Messaging System . . . . . 471<\/li>\r\n<li>Message Handlers in Delphi . . . . . 471<\/li>\r\n<li>Practical Examples . . . . . 472<\/li><\/ul>\r\n<p>26. Programmer\u2019s toolbox . . . . . 474<\/p>\r\n<ul>\r\n<li>Delphi registry secret . . . . . 474<\/li>\r\n<li>How to start a \u201Cmint\u201D Delphi instance? . . . . . 475<\/li>\r\n<li>Total Commander . . . . . 476<\/li>\r\n<li>SoftPerfect RAMDisk . . . . . 478<\/li>\r\n<li>Version control . . . . . 479<\/li>\r\n<li>Do we need a repository? . . . . . 480<\/li>\r\n<li>Creating a new Tortoise repository . . . . . 482<\/li>\r\n<li>Revisions . . . . . 484<\/li>\r\n<li>Resolving Conflicts . . . . . 485<\/li>\r\n<li>Commit Progress . . . . . 486<\/li>\r\n<li>Icon overlays . . . . . 486<\/li>\r\n<li>Shelving . . . . . 486<\/li>\r\n<li>Normalizers . . . . . 487<\/li><\/ul>\r\n<p>27. Code safety . . . . . 490<\/p>\r\n<ul>\r\n<li>Things that are ok, but dangerous . . . . . 490<\/li>\r\n<li>Delphi language . . . . . 491<\/li>\r\n<li>\u201CSimply don\u2019t do it\u201D . . . . . 494<\/li>\r\n<li>Letting the compiler to help us . . . . . 494<\/li>\r\n<li>Extra techniques . . . . . 495<\/li>\r\n<li>Program architecture . . . . . 495<\/li>\r\n<li>Some details . . . . . 496<\/li>\r\n<li>On FreeAndNil . . . . . 497<\/li>\r\n<li>A word of warning on Application.ProcessMessages . . . . . 498<\/li><\/ul>\r\n<p>28. Advance topics . . . . . 500<\/p>\r\n<ul>\r\n<li>Running a single instance of our program . . . . . 500<\/li>\r\n<li>How does it work? . . . . . 500<\/li>\r\n<li>Let\u2019s see the code . . . . . 501<\/li>\r\n<li>Anonymous methods . . . . . 502<\/li>\r\n<li>Capture of Variables . . . . . 503<\/li>\r\n<li>Usage . . . . . 503<\/li>\r\n<li>Flexible Usage . . . . . 504<\/li>\r\n<li>Inline Definitions . . . . . 504<\/li>\r\n<li>Analyzing the code above . . . . . 504<\/li><\/ul>\r\n<p> . . . . . 29. Migrating 32-bit Code to 64-bit: Best Practices and Considerations . . . . . 506<\/p>\r\n<ul>\r\n<li>Before you start . . . . . 506<\/li>\r\n<li>Upgrading Third-Party Libraries . . . . . 506<\/li>\r\n<li>Adding 64-bit Support to the Project . . . . . 506<\/li>\r\n<li>Fixing the paths . . . . . 506<\/li>\r\n<li>Inspecting the code . . . . . 507<\/li>\r\n<li>Choosing the correct data types . . . . . 507<\/li>\r\n<li>Typecast from pointer to integer . . . . . 508<\/li>\r\n<li>Typecast between Record and TObject . . . . . 509<\/li>\r\n<li>WinAPI issues . . . . . 509<\/li>\r\n<li>SendMessage . . . . . 510<\/li>\r\n<li>Vcl.Controls.TControl.Perform . . . . . 510<\/li>\r\n<li>SetWindowLong\/ GetWindowLong . . . . . 511<\/li>\r\n<li>SetWindowLong: . . . . . 511<\/li>\r\n<li>Avoid using LongInt . . . . . 512<\/li>\r\n<li>Extended type . . . . . 512<\/li>\r\n<li>Inline ASM code . . . . . 513<\/li>\r\n<li>Functions that return Cardinal instead of Pointer . . . . . 513<\/li>\r\n<li>Summary . . . . . 513<\/li><\/ul>\r\n<p>30. Deploying our application on other platforms . . . . . 515<\/p>\r\n<ul>\r\n<li>Android . . . . . 515<\/li>\r\n<li>Apple . . . . . 515<\/li>\r\n<li>Linux . . . . . 516<\/li>\r\n<li>Summary . . . . . 516<\/li><\/ul>\r\n<p>31. Being a programmer . . . . . 517<\/p>\r\n<p>32. All good things must come to an end . . . . . 522<\/p>\r\n<ul>\r\n<li>Where do you go from here? . . . . . 522<\/li>\r\n<li>Your next big project could be a game . . . . . 522<\/li>\r\n<li>About Stack Overflow . . . . . 523<\/li>\r\n<li>Fighting bullies on Stack Overflow . . . . . 523<\/li>\r\n<li>Ask the artificial intelligence . . . . . 524<\/li>\r\n<li>Video tutorials . . . . . 527<\/li>\r\n<li>Books . . . . . 527<\/li>\r\n<li>My books . . . . . 527<\/li>\r\n<li>Already published books: . . . . . 528<\/li>\r\n<li>What I have learned in the last 25 years of software development . . . . . 528<\/li><\/ul>\r\n<p>33. Appendix . . . . . 532<\/p>\r\n<ul>\r\n<li>Files generated by Delphi . . . . . 532<\/li>\r\n<li>Example of ASM code in Pas file: . . . . . 533<\/li>\r\n<li>Delphi releases . . . . . 534<\/li>\r\n<li>What's new since Delphi 10.0? . . . . . 535<\/li><\/ul>\r\n<p>34. Notes and credits . . . . . 539<\/p>\r\n<ul>\r\n<li>Contact me! . . . . . 539<\/li>\r\n<li>Disclaimer . . . . . 539<\/li>\r\n<li>Source code . . . . . 539<\/li>\r\n<li>Be environment responsible . . . . . 539<\/li>\r\n<li>Credits . . . . . 539<\/li><\/ul>"}],
"keywords":[
]}