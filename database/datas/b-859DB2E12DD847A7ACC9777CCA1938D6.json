{
"id":141,
"guid":"859DB2E12DD847A7ACC9777CCA1938D6",
"pagename":"Delphi-in-all-its-glory-part-2-Reaching-for-the-Gods.html",
"datalevel":8,
"dataversion":1,
"name":"Delphi in all its glory (part 2) : Reaching for the Gods",
"lang":"en",
"pubdate":"20240131",
"isbn13":"9798878103749",
"website":"https:\/\/gabrielmoraru.com\/publications-citations\/the-delphi-in-all-its-glory-2-book\/",
"authors":[
{
"id":51,
"guid":"A08AFCB8DA18EE118C5C32A5A9F17050",
"pagename":"Gabriel-Moraru.html",
"datalevel":7,
"dataversion":1}],
"publishers":[
],
"descriptions":[
{
"guid":"68E62CF157544D4BAF4C2CCC219545FF",
"pagename":"",
"datalevel":4,
"dataversion":1,
"lang":"en",
"text":"<p>This book is hands-on, pragmatic, and focused on solving real-world issues.<br\/><br\/>We\u2019ll start with an in-depth look at the Delphi compiler (linker, precompiled libraries, library paths). Then, we\u2019ll move on to advanced debugging: reading call stacks, using advanced breakpoints, remote debugging, and leveraging third-party tools for automated bug reporting and crash data collection. You\u2019ll learn to how to set the compiler to help you pinpoint crashes and even prevent them entirely on your customer\u2019s computer.<br\/><br\/>Next, we\u2019ll tackle memory management (memory ownership, preventing and dealing with memory corruption) and proper exception handling (covering crashes, access violations, nil pointers, etc). For legacy developers, there\u2019s a section on modernizing old Delphi code for safety, speed, and 64-bit compatibility.<br\/><br\/>Additional topics include version control, multi-threading, Windows messages, and avoiding common pitfalls like buffer overflows, Application.ProcessMessages, abusing pointers, etc.<br\/><br\/>I promise that by applying the concepts in this book, your application will run smoothly\u2014without any crashes!&nbsp;<\/p>"}],
"tocs":[
{
"guid":"0209DC9B88EC4979B3E8780DABDBF30F",
"pagename":"",
"datalevel":5,
"dataversion":1,
"lang":"en",
"text":"<p>1. Intro<\/p><p>2. Table of content<\/p><p>3. The Delphi compiler<\/p><p>What is a compiler? What is an interpreter? 23<br\/>Compiled vs interpreted 23<br\/>A reliable compiler 25<br\/>The toolchain 27<br\/>Executable size 28<br\/>Compiler speed 29<br\/>From Pas to Exe 31<br\/>The compilation order 33<br\/>Compiling and running the program 34<br\/>DCUs 35<br\/>Debug vs Release DCUs 35<br\/>The linker 39<br\/>Compile vs Build 40<br\/>Improving compiler\u2019s speed 41<br\/>Remove unused units 41<br\/>Rearrange the units in the uses section 42<br\/>Unused paths 43<\/p><p>4. Libraries<\/p><p>Why do we need libraries? 45<br\/>Libraries are not for everyone 45<br\/>The four rules of creating packages 47<br\/>Library architecture 49<br\/>Circular references 51<br\/>It is all about aliens and pyramids 52<br\/>The anatomy of a package 53<br\/>DPK 53<br\/>BPL\/DCP 58<br\/>Project groups 62<br\/>Compiler Directives 63<br\/>Delphi\u2019s framework 64<br\/>The RTL library 64<br\/>The VCL library 65<br\/>Library paths 66<br\/>Environment variables 66<br\/>Compiling with multiple Delphi versions 69<br\/>Finding files via Library paths 70<br\/>Search Paths 79<br\/>Under-development libraries 79<br\/>Global vs local paths 80<br\/>Precompiled files 81<br\/>Precompiling our own files 82<br\/>The \u201CPackage\/DCP\/HPP output directory\u201D fields 83<br\/>Project Paths 84<br\/>Recap 84<br\/>How to install a library? 86<br\/>Installing a library manually 86<br\/>Single-file libraries 91<br\/>What to do when things go south? 91<br\/>Library folder structure 92<br\/>Installing libraries via Setup 93<br\/>Creating our own installer 93<br\/>IDE plugins 94<br\/>Installing libraries via GetIt 95<br\/>How to uninstall a library 96<br\/>Runtime\/Designtime libraries 97<br\/>Run-time libraries 97<br\/>Design time libraries 98<br\/>Design time vs Runtime 98<br\/>Including a library in our project 99<br\/>Linking with runtime packages 101<br\/>Drawbacks 102<br\/>How does the linker optimize unused code? 104<br\/>Experiment calibration 106<br\/>Proceedings 106<br\/>Extension to the experiment 112<br\/>Debugging 3rd party libraries 114<br\/>Recompiling parts of the VCL 117<br\/>Why libraries are mandatory for large projects? 120<br\/>Logic separation 120<br\/>The Chaos of Monolithic Projects 125<br\/>The Breaking Point 125<br\/>The Refractory Ignition Spark 125<br\/>A Better Way: Modular Code via Libraries 126<br\/>Overcoming Preconceptions 126<br\/>Using C\/++ libraries in Delphi 128<br\/>When you have the source code 128<br\/>When you have the DLL 128<br\/>Popular libraries 131<br\/>LightSaber 134<br\/>Proteus 143<br\/>About libraries and licenses 157<br\/>Meaning of the fields 157<br\/>Discussions 159<br\/>Conclusions 160<br\/>More details 160<br\/>The Initialization of packages 161<br\/>The Register procedure 163<br\/>Building our own visual components 165<\/p><p>5. Automatic compilation<\/p><p>Using MSBuild in Delphi: 170<\/p><p>6. The debugger<\/p><p>What is a debugger? 175<br\/>Preparing our project for debugging 176<br\/>Stacks 176<br\/>Configurations 178<br\/>The \u201CCompiling\u201D page 179<br\/>The \u201CUse debug DCUs\u201D field 182<br\/>Other settings 184<br\/>A picture is worth a thousand words. 184<br\/>The \u201CLinking\u201D page 186<br\/>The \u201CDebug source path\u201D field 188<br\/>Breakpoints 190<br\/>Breakpoint properties 191<br\/>Relocate the execution point manually 192<br\/>Finally, ready to debug 194<br\/>Starting the program under the debugger 194<br\/>Debugging from a crash point 196<br\/>Cannot debug? 199<br\/>Fun stuff to do during debugging 200<br\/>Hint for geeks 203<br\/>Debugging cheat sheet 204<\/p><p>7. Remote debugging<\/p><p>How does it work? 207<br\/>Install PAserver (on the remote machine) 208<br\/>Run PAServer (on the remote machine) 209<br\/>Configure the environment (locally) 209<br\/>Assign a Connection Profile to the Delphi project 213<br\/>Choose which files to deploy 215<br\/>Deploying the files manually 215<br\/>Start debugging 216<br\/>Stability 218<\/p><p>8. Automatic bug logging &amp; reporting<\/p><p>MadShi MadExcept 222<br\/>EurekaLog 225<\/p><p>9. Advanced debugging techniques<\/p><p>Method 1: Attach to process 228<br\/>Method 2: Debug with \u201CRun -&gt; Load process\u201D. 229<br\/>Method 3: Host application (Recommended) 234<br\/>Method 4: External tools 236<br\/>Method 5: Start Delphi in \u201Csafe\u201D mode 236<br\/>Method 6: Use external tools 236<br\/>Stupid Windows 10 237<\/p><p>10. Speed up your program<\/p><p>Profiling your program 240<br\/>Home-brewed method (as cheap as the home-made beer) 240<br\/>Third party profilers (aka non-free) 242<br\/>Improving the speed 244<br\/>Record field alignment 244<br\/>CPU Optimization 248<br\/>Compared to Julia 249<\/p><p>11. Compiler! Please save my ass!<\/p><p>Overflow checking 258<br\/>IO checking 259<br\/>Range Checking 260<br\/>Enabling Runtime Error Checking 260<br\/>Temporary disabling range checking 262<br\/>Assertions 264<br\/>Assert vs Raise 266<br\/>Nothing comes for free 267<\/p><p>12. Memory management<\/p><p>FastMM 270<br\/>1. Dramatic speed increase for memory-bound operations 270<br\/>2. Prevents memory fragmentation 270<br\/>3. Better memory sharing 271<br\/>4. Safer code 271<br\/>5. No more access violations 275<br\/>Switching FastMM to Full Debug Mode 277<br\/>How to read a FastMM leak report? 278<br\/>The summary 279<br\/>Leaked blocks 279<br\/>Advanced topics 283<br\/>You create it, you kill it 283<br\/>Memory ownership 284<br\/>Dangling references 284<br\/>Alice loses her preferred book 284<br\/>Getting our dirty paws on a dangling reference 285<br\/>The root of all evil 288<br\/>There are even worst scenarios 289<br\/>Do some noise 289<br\/>Bruce Willis (and FastMM) saves the day\u2026 again! 291<br\/>Garbage collectors 293<br\/>About ownership 294<br\/>Passing the ownership around 295<br\/>Summary 297<\/p><p>13. Exceptions<\/p><p>Exception Handling 302<br\/>Let\u2019s do the \u201CWhat this code does\u201D game 305<br\/>Amateur mistake 306<br\/>Keep it real 310<br\/>Spit, don\u2019t swallow 311<br\/>Good boy, Debugger! 314<br\/>Ignoring exceptions during debugging 316<br\/>Try\/Finally vs Try\/Except 318<br\/>Raising exceptions 320<\/p><p>14. Windows Messages in Delphi<\/p><p>The Windows Messaging System 324<br\/>Message Handlers in Delphi 325<br\/>Practical Examples 326<\/p><p>15. Programmer\u2019s toolbox<\/p><p>Delphi registry secrets 329<br\/>Restoring the registry 331<br\/>How to start a \u201Cmint\u201D Delphi instance? 333<br\/>Total Commander 335<br\/>SoftPerfect RAMDisk 338<br\/>Version control 339<br\/>Do we need a repository? 340<br\/>Creating a new Tortoise repository 343<br\/>Revisions 345<br\/>Resolving Conflicts 347<br\/>Commit Progress 348<br\/>Icon overlays 348<br\/>Shelving 349<br\/>Normalizers 350<\/p><p>16. Code safety<\/p><p>Things that are ok, but dangerous 354<br\/>Don\u2019t use pointers 354<br\/>Don\u2019t do direct typecasts 355<br\/>Avoid threads 355<br\/>Avoid TTimer 355<br\/>Avoid using unsafe functions 355<br\/>Things related to the Delphi language 357<br\/>Use strong typing 357<br\/>Avoid \u201Cwith\u201D 357<br\/>Use assertions. Abundantly 358<br\/>Document your code 358<br\/>Follow coding standards 358<br\/>Extra care with Interfaces 358<br\/>Perform boundary checks 359<br\/>Avoid using unsafe functions 359<br\/>Handling Boundary Values 359<br\/>Dealing with Wrapping 360<br\/>Simply \u201Cdon\u2019t do it\u201D 361<br\/>Don\u2019t swallow exceptions 361<br\/>Don\u2019t use Application.ProcessMessages 361<br\/>Letting the compiler to help us 362<br\/>Activate rage checking 362<br\/>Activate I\/O checking 362<br\/>Activate integer overflow 362<br\/>Activate compiler hints and warnings 362<br\/>Other runtime checks 363<br\/>Enable FastMM to check for memory leaks 363<br\/>Implement \u201Csafety net\u201D for enumerations 363<br\/>Use Free instead of FreeAndNil 363<br\/>Extra techniques 364<br\/>Test program thoroughly 364<br\/>Implement Unit Testing for your code. 364<br\/>Use a bug tracking tool, like MadShi! 364<br\/>External libraries 364<br\/>Encapsulate your code 365<br\/>Cheat sheet 366<br\/>Quantify the source of errors 368<br\/>Classification of error types: 368<br\/>Program architecture 371<br\/>Extra stuff to check for 372<br\/>On FreeAndNil 374<br\/>A word of warning on Application.ProcessMessages 376<br\/>TControl.Perform 378<br\/>Safely storing a list of objects 380<br\/>Security update 2024 385<\/p><p>17. Advance topics<\/p><p>Running a single instance of our program 388<br\/>How does it work? 388<br\/>Let\u2019s see the code 389<br\/>Anonymous methods 391<br\/>Capture of Variables 392<br\/>Usage 392<br\/>Flexible Usage 393<br\/>Inline Definitions 393<br\/>Analyzing the code above 394<br\/>Multithreading in Delphi 395<br\/>Delphi\u2019s Multithreading Infrastructure 397<br\/>Creating Threads with TThread 397<br\/>Thread Safety 398<br\/>Synchronization with the Main GUI Thread 398<br\/>Using TThread.Synchronize 398<br\/>Using TThread.Queue 399<br\/>Other synchronization mechanisms: 400<br\/>Best Practices for Multithreading 401<br\/>1. Plan Your Multithreading Strategy 401<br\/>2. Handle Exceptions Gracefully 401<br\/>3. Minimize Shared Data 401<br\/>Common Pitfalls to Avoid 401<br\/>Delphi Parallel Programming Library (PPL) 402<br\/>Hardware limitations 402<\/p><p>18. Migrating 32-bit Code to 64-bit: Best Practices and Considerations<\/p><p>Alternative paths 405<br\/>How to set the LARGE_ADDRESS_AWARE? 406<br\/>Before you start 407<br\/>Upgrading Third-Party Libraries 407<br\/>Adding 64-bit Support to the Project 407<br\/>Fixing the paths 407<br\/>Inspecting the code 409<br\/>Choosing the correct data types 409<br\/>Typecast from pointer to integer 411<br\/>Typecast between Record and TObject 412<br\/>WinAPI issues 413<br\/>SendMessage 413<br\/>Vcl.Controls.TControl.Perform 413<br\/>SetWindowLong\/ GetWindowLong 414<br\/>SetWindowLong: 414<br\/>SetWindowLongPtr: 415<br\/>Special types 417<br\/>Avoid using LongInt 417<br\/>Extended type 417<br\/>Inline ASM code 418<br\/>Functions that return Cardinal 419<br\/>Summary 420<\/p><p>19. Deploying our application on other platforms<\/p><p>Android 421<br\/>Apple 422<br\/>Linux 422<br\/>Summary 424<\/p><p>20. Being a programmer<\/p><p>Change is good\u2026 but hard 426<br\/>On Technical Debt 433<br\/>Rocking the boat 435<br\/>So, do you still want to do it? 437<\/p><p>21. All good things must come to an end<\/p><p>Where do you go from here? 441<br\/>Delphi sample projects 441<br\/>Your next big project could be a game 442<br\/>About Stack Overflow 443<br\/>Fighting bullies on Stack Overflow 443<br\/>Ask the artificial intelligence 445<br\/>Video tutorials 448<br\/>Books 449<br\/>My books 450<br\/>Already published books: 450<br\/>What I have learned in the last 25 years of software development 451<\/p><p>22. Notes and credits<\/p><p>Contact me! 456<br\/>Disclaimer 456<br\/>Source code 456<br\/>Be environment-responsible 456<br\/>Credits 457&nbsp;<\/p>"}],
"keywords":[
]}