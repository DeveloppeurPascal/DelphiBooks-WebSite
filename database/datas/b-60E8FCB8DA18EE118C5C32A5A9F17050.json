{
"id":123,
"url":"",
"guid":"60E8FCB8DA18EE118C5C32A5A9F17050",
"pagename":"Delphi-Thread-Safety-Patterns.html",
"datalevel":8,
"dataversion":1,
"ispagetobuild":true,
"name":"Delphi Thread Safety Patterns",
"lang":"en",
"pubdate":"20220531",
"thumb":"",
"isbn10":"",
"isbn13":"",
"website":"https:\/\/dalija.prasnikar.info\/delphitspatt\/",
"cover":"",
"cover_100w":"",
"cover_150w":"",
"cover_200w":"",
"cover_300w":"",
"cover_400w":"",
"cover_500w":"",
"cover_100h":"",
"cover_200h":"",
"cover_300h":"",
"cover_400h":"",
"cover_500h":"",
"cover_100x100":"",
"cover_200x200":"",
"cover_300x300":"",
"cover_400x400":"",
"cover_500x500":"",
"cover_130x110":"",
"authors":[
{
"id":48,
"url":"",
"guid":"EA81FCB8DA18EE118C5C32A5A9F17050",
"pagename":"Dalija-Prasnikar.html",
"datalevel":6,
"dataversion":1,
"ispagetobuild":true,
"name":""
},{

"id":49,
"url":"",
"guid":"4883FCB8DA18EE118C5C32A5A9F17050",
"pagename":"Prasnikar-Neven-Jr.html",
"datalevel":6,
"dataversion":1,
"ispagetobuild":true,
"name":""}],
"publishers":[
],
"descriptions":[
{
"guid":"C4E8FCB8DA18EE118C5C32A5A9F17050",
"pagename":"",
"datalevel":3,
"dataversion":1,
"ispagetobuild":true,
"lang":"en",
"text":"<p>While the thread safety of a particular piece of code depends on the surrounding context and how it is used, some data types are inherently unsafe, and for some of them, thread safety will depend on the use case and the specific code. Unfortunately, when you look at some class, type declaration, or API in isolation, there is very little information there that will tell you whether instances of that type can be safely used in multiple threads, or under which conditions.<\/p>\n<p>The proper place to learn about the thread safety of an API is its documentation. However, most documentation will not explicitly give you that information. Occasionally, the documentation will mention that a particular feature is not thread-safe, or will tell you that a feature can be used in background threads, but for the most part, you will have to figure out thread safety on your own. One reason for this is that thread safety depends on the context. The number of features that are absolutely unsafe or are absolutely safe is very small.<\/p>\n<p>The basic thread safety rules are simple, but applying those rules is more complicated. Just as design patterns give us general solutions to common coding problems, we can extract common coding patterns from various multithreaded code\u2014thread safety patterns.<\/p>\n<p>This book converts the thread safety rules into practice, and gives an overview of core Delphi frameworks and commonly used features from a thread safety perspective. You will find examples of how particular classes can be used in a thread-safe manner and how to perform some common tasks, following the already established thread safety patterns.<\/p>\n<p>Besides elaborating on the thread safety of particular parts of Delphi frameworks, the book explores the thread safety of alternate solutions, along with general coding examples. Every explanation about why some code is thread-safe or not, also serves as an example of thread (un)safety patterns, and helps in recognizing thread-unsafe code, as well as establishing a working set of thread safety patterns that can later be applied in custom code.<\/p>\n<p>Those examples, covering the most commonly used parts of Delphi frameworks, will also serve as learn by example pointers for determining the thread safety of other parts of the frameworks, and even of 3rd-party libraries that are not specifically covered in this book.<\/p>\n<p>There are also implementations and examples of some commonly used concepts in asynchronous programming that are not part of the core Delphi frameworks, but can be indispensable when writing multithreaded code.<\/p>"}],
"tocs":[
{
"guid":"F6E8FCB8DA18EE118C5C32A5A9F17050",
"pagename":"",
"datalevel":3,
"dataversion":1,
"ispagetobuild":true,
"lang":"en",
"text":"<p>Introduction<\/p>\n<p>Part 1. Thread Safety<\/p>\n\n<p>* Language and general thread safety<br>\n* Proving thread safety<br>\n* Examples<br>\n   + Data type thread safety<br>\n   + Thread-safe data types used in an unsafe manner<br>\n   + Code thread safety<\/p>\n\n<p>Part 2. The Core Run-Time Library<\/p>\n\n<p>* Global state<br>\n* Floating-point control register<br>\n* FormatSettings and formatting routines<br>\n* Global functions and procedures<br>\n   + Parameters<br>\n   + FreeAndNil<br>\n   + Class methods<br>\n   + Other global functions<br>\n* Class fields, singletons, and default instances<br>\n   + Class constructors and initialization section<br>\n   + Thread-safe lazy initialization<br>\n   + Writeable instances<br>\n* Core classes<br>\n   + Core classes<br>\n   + Custom classes<br>\n* Threads<br>\n   + FreeOnTerminate<br>\n   + Starting a thread<br>\n   + Order of destruction<br>\n   + Custom thread's data<br>\n* Streams<br>\n* Collections<br>\n   + Making a thread-safe variant of a thread-unsafe collection<br>\n   + Thread-safe iteration<br>\n   + Partial locking<br>\n   + False sense of the security<br>\n   + Wrappers vs inheritance<br>\n   + Immutable collections<br>\n* Parallel collection processing<br>\n* Components<br>\n   + Using components in background threads<br>\n   + Component streaming<br>\n* RTTI<\/p>\n\n<p>Part 3. Core Frameworks<\/p>\n\n<p>* Serialization<br>\n   + Protecting the Data<br>\n     - Unshared data<br>\n     - Read-only data<br>\n     - Mutable data protected by a synchronization mechanism<br>\n   + Protecting the serializer<br>\n     - Function, procedure or class method<br>\n     - Stateless or immutable serializer instance<br>\n     - Stateful serializer instance<br>\n   + Net encoding classes<br>\n   + JSON<br>\n   + XML<br>\n* System.Net<br>\n* Asynchronous Programming Library<br>\n* Indy<br>\n* REST<br>\n* Regular expressions<\/p>\n\n<p>Part 4. Visual Frameworks - VCL and FMX<\/p>\n\n<p>* Visual framework components<br>\n* LiveBindings<br>\n* VCL and FMX controls<br>\n* Interactions with OS APIs and frameworks<br>\n   + Window allocation and de-allocation<br>\n   + Windows messaging<br>\n   + Timers<\/p>\n\n<p>Part 5. Graphics and Image Processing<\/p>\n\n<p>* Graphics and image processing<br>\n   + Graphics and image processing<br>\n   + Graphics platforms and frameworks<br>\n* Resource consumption<br>\n* Common graphics types and API<br>\n* VCL graphics types and API<br>\n   + Fonts, pens, and brushes<br>\n   + Canvas<br>\n   + Graphics<br>\n   + Picture<br>\n   + Vcl.GraphUtil<br>\n   + VCL image collections<br>\n* VCL graphics example<br>\n* FMX graphics types and API<\/p>\n\n<p>Part 6. Custom Frameworks<\/p>\n\n<p>* Writing custom frameworks<br>\n* Logging<br>\n* Cancellation tokens<br>\n* Event bus<br>\n* Measuring performance<\/p>\n\n<p>Appendix<\/p>\n\n<p>* References<br>\n* Quality Portal Reports<\/p>"}],
"keywords":[
]}