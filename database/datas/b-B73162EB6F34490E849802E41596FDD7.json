{
"id":146,
"guid":"B73162EB6F34490E849802E41596FDD7",
"pagename":"Delphi-in-all-its-glory-part-3-Libraries.html",
"datalevel":7,
"dataversion":1,
"name":"Delphi in all its glory (part 3) : Libraries",
"lang":"en",
"pubdate":"20240424",
"isbn13":"9798323881222",
"website":"https:\/\/gabrielmoraru.com\/publications-citations\/delphi-in-all-its-glory-book-3\/",
"authors":[
{
"id":51,
"guid":"A08AFCB8DA18EE118C5C32A5A9F17050",
"pagename":"Gabriel-Moraru.html",
"datalevel":7,
"dataversion":1}],
"publishers":[
],
"descriptions":[
{
"guid":"BEC0FE33A48F4B40BD1FD617D165C974",
"pagename":"",
"datalevel":3,
"dataversion":1,
"lang":"en",
"text":"<p>This book is hands-on, pragmatic, and focused on solving real-world issues.<br\/><br\/>We\u2019ll start by studying the anatomy of a Delphi package and its famous BPL\/DCP files. You\u2019ll learn how packages can help organize your code, break circular references, and will do some Zen, studding the four rules of packaging.<br\/><br\/>Next, we\u2019ll dive into the inner workings of Delphi\u2019s library system (VCL), including how to recompile parts of it \u2014 if necessary.<br\/><br\/>From there, we\u2019ll explore practical techniques: how to design and set up your own library system, leverage precompiled code to dramatically boost compilation speed, and, of course, tackle the ever-important topic of managing library paths.<br\/><br\/>While building custom visual components isn\u2019t the primary focus, we\u2019ll dedicate a chapter to it with sample code, including discussions about design-time and runtime packages.<br\/><br\/>Finally, to become true professionals, we\u2019ll venture neck-deep into the gritty details of packages: the linker, package initialization, constructors and destructors, component streaming, component states, debugging packages, and even the IDE itself.<br\/><br\/>As you can see, no stone was left unturned in this book!&nbsp;<\/p>"}],
"tocs":[
{
"guid":"D499B45004DA493D9C9E84B56A1E9D6D",
"pagename":"",
"datalevel":4,
"dataversion":1,
"lang":"en",
"text":"<p>1. Overview<\/p><p>Intended Audience 3<br\/>Always focused on code-safety 4<br\/>How is this book written? 4<br\/>Environment-responsible 5<br\/>Who am I? 6<br\/>Pre-requisites for this book 6<br\/>Let\u2019s start 6<\/p><p>2. Table of content<\/p><p>Symbols and conventions 15<\/p><p>3. Introduction<\/p><p>Why do we need libraries? 16<br\/>You could survive without libraries\u2026 if you develop a single, small program 17<\/p><p>4. What is a library<\/p><p>5. About libraries and licenses<\/p><p>Meaning of the fields 21<br\/>Discussions 23<br\/>GPL 23<br\/>LGPL \u2013 Dynamic vs static linking 23<br\/>Apache 23<br\/>Mozilla Public License 24<br\/>CC, MIT, BSD 24<br\/>Conclusions 24<\/p><p>6. The four rules of packages<\/p><p>Rule #1: Always separate your business-logic code from the GUI code. 25<br\/>Rule #2: There should be no floating units. 25<br\/>Rule #3: A unit can belong to a project (dpr, dpk) and only one project. 25<br\/>Rule #4: The unit of a low-level library cannot access a unit in a higher-level library. 25<\/p><p>7. Library architecture<\/p><p>Circular references 30<br\/>It is all about aliens and pyramids 31<br\/>When to start being a pharaoh? 31<\/p><p>8. The anatomy of a Delphi package<\/p><p>DPK 33<br\/>The \u201CContains\u201D section 33<br\/>The \u201CRequires\u201D section 34<br\/>A unit can be contained by only one package 36<br\/>How do we fix this? 38<br\/>BPL\/DCP 40<br\/>Where are the DCU, DCP &amp; BPL files needed? 40<br\/>Design time BPLs 40<br\/>Chained packages 41<br\/>Changing the BPL folder 42<br\/>Project groups 44<br\/>Compiler Directives 45<\/p><p>9. Delphi\u2019s framework<\/p><p>The RTL library 46<br\/>The VCL library 47<\/p><p>10. Compiler paths<\/p><p>Path precedence 49<br\/>Paths are unique for each platform 50<br\/>Environment variables 51<br\/>$(BDS) 51<br\/>$(ProductVersion) 51<br\/>$(Platform) 51<br\/>$(Config) 52<br\/>$(Auto) 52<br\/>Library paths 55<br\/>1. Delphi libraries 55<br\/>2. Third party libraries 56<br\/>3. Our own libraries 58<br\/>Do we really need Library Paths? 58<br\/>Search Paths 60<br\/>Abusing the search paths in packages 60<br\/>Abusing the search paths in projects 60<br\/>Under-development libraries 61<br\/>Global vs local paths 62<br\/>Recap 62<br\/>Other paths 64<br\/>Browsing path 64<br\/>Release vs Debug DCUs 65<br\/>Project paths 67<\/p><p>11. RTL\/VCL is precompiled<\/p><p>Precompiling our own files 71<br\/>When to precompile our files? 71<br\/>The \u201CPackage output directory\u201D fields 72<\/p><p>12. How to install a library?<\/p><p>Installing a library manually 74<br\/>1. Open the package 74<br\/>2. Install the package 74<br\/>3. Let the compiler find the library 75<br\/>4. Confirm that the library was installed correctly 77<br\/>Installing a library delivered without PAS files 78<br\/>Single-file libraries 79<br\/>What to do when things go south? 80<br\/>Library folder structure 81<br\/>Installing libraries via Setup 82<br\/>Creating our own installer 82<br\/>IDE plugins 83<br\/>Trivia 83<br\/>Installing libraries via GetIt 84<br\/>How to uninstall a library 85<\/p><p>13. Runtime\/Designtime libraries<\/p><p>Run-time libraries 87<br\/>Design time libraries 88<br\/>Design time vs Runtime 89<br\/>Including a library in our project 91<\/p><p>14. Linking with runtime packages<\/p><p>Drawbacks 93<\/p><p>15. How does the linker optimize unused code?<\/p><p>Experiment calibration 98<br\/>Proceedings 99<br\/>Experiment 1 99<br\/>Experiment 2 99<br\/>Experiment 3 100<br\/>Experiment 4 100<br\/>Experiment 5 103<br\/>Results 104<br\/>Extension to the experiment 105<br\/>The design time package 105<br\/>Some definitions and clarifications 106<\/p><p>16. Recompiling parts of the VCL<\/p><p>1. Class hack 107<br\/>2. Recompile the patched VCL file 107<\/p><p>17. Why libraries are mandatory for large projects?<\/p><p>Logic separation 111<br\/>Business logic 111<br\/>The GUI code 111<br\/>Code separation 111<br\/>Parentheses \u2013 Image recognition algorithm 113<br\/>Applicability 113<br\/>Reusability of the code 115<br\/>Avoiding circular references 115<\/p><p>18. The chaos of monolithic projects<\/p><p>The Breaking Point 117<br\/>The Refractory Ignition Spark 117<br\/>A Better Way: Modular Code via Libraries 118<br\/>Overcoming Preconceptions 118<\/p><p>19. Using C\/++ libraries in Delphi<\/p><p>When you have the source code 120<br\/>When you have the DLL 120<\/p><p>20. Package initialization<\/p><p>The Register procedure 126<\/p><p>21. Popular libraries<\/p><p>FastMM4 127<br\/>Graphics32 127<br\/>Delphi LightSaber 127<br\/>Jedi 128<br\/>TMS 129<br\/>LightSaber 130<\/p><p>22. Proteus Licensing System<\/p><p>What is Proteus? 140<br\/>Trial license 140<br\/>Rent license (aka subscription) 141<br\/>Permanent license 141<br\/>Modules 141<br\/>Free Proteus license for you 141<br\/>What can Proteus do for you? 142<br\/>Automates the process of selling your app. 142<br\/>Prevents fraud 142<br\/>HardwareID-based keys 14<br\/>Proteus can even do marketing 143<br\/>How to use it? (Overview) 144<br\/>Typical usage scenario 144<br\/>Is it difficult to integrate Proteus into my app? 144<br\/>Definitions 146<br\/>Certificate 146<br\/>Unlock key 147<br\/>Library structure 152<br\/>Classes 153<br\/>TProteus 153<br\/>RCertificate 153<br\/>Support code 155<br\/>Self protection 156<br\/>Under the hood 156<br\/>Anti-tampering system 156<br\/>Stolen keys 156<br\/>How to add a \u2018Stolen keys\u2019 list to your project? 157<br\/>Amnesty key 157<br\/>Certificate ID 158<br\/>Entering the same key twice 158<br\/>Active certificate 160<br\/>Initialization 160<br\/>Setting up your app \u2013 Step by step guide 161<br\/>Demo program 163<\/p><p>23. Building a visual component<\/p><p>General steps for creating a visual component 164<br\/>Writing our first visual component 165<\/p><p>24. All good things must come to an end<\/p><p>Where do you go from here? 174<br\/>Delphi sample projects 174<br\/>Your next big project could be a game 175<br\/>Ask the artificial intelligence 175<br\/>Books 178<br\/>Notes and credits 180<\/p>"}],
"keywords":[
]}