{
"id":144,
"guid":"09426F577CAA4A92BE076C80B58E151D",
"pagename":"Delphi-Quality-Driven-Development.html",
"datalevel":8,
"dataversion":1,
"name":"Delphi Quality-Driven Development",
"lang":"en",
"pubdate":"20250212",
"isbn13":"9798310465060",
"website":"https:\/\/dalija.prasnikar.info\/delphiqdd\/index.html",
"authors":[
{
"id":48,
"guid":"EA81FCB8DA18EE118C5C32A5A9F17050",
"pagename":"Dalija-Prasnikar.html",
"datalevel":6,
"dataversion":1
},{

"id":49,
"guid":"4883FCB8DA18EE118C5C32A5A9F17050",
"pagename":"Prasnikar-Neven-Jr.html",
"datalevel":6,
"dataversion":1}],
"publishers":[
],
"descriptions":[
{
"guid":"84A3E3460733485595E10847B2C2BC1A",
"pagename":"",
"datalevel":4,
"dataversion":1,
"lang":"en",
"text":"<p>Software development is a complex and continuous process. The quality of the end result\u2014the actual software\u2014depends on many variables. Regardless of the size of the team, be it a solo developer, or a team with tens, hundreds, or even thousands of people involved, we cannot always fully control all the aspects of the software development process.<\/p><p>However, we can bring some order into the chaos, and by using well-established and proven practices, we can increase the quality of the software we are producing, and with that, increase customer satisfaction, ultimately improving the success of the software product.<\/p><p>There are always other factors that determine the success (viability) of the software, but a bug-ridden product is never going to be a successful one, unless users are forced to use it for reasons beyond their control.<\/p><p>When it comes to reducing the number of current and future bugs and other quality issues in the software, there is one thing in particular that can and will do more for improving software quality than all the others combined: automated testing.<\/p><p>In that light, the main title of this book could have easily been its subtitle alone: A practical guide to testing and writing testable code. However, the ability to test software requires way more than the mere act of testing or writing testable code, and covering only those two aspects would fail to address other significant factors that contribute not only to the overall quality of the produced software, but also our ability to successfully write and test its code.<br\/>While topics surrounding testing and writing testable code do comprise the most significant part of this book, all other parts of the development process that also contribute to the software quality are covered, to give a better understanding of their roles and impact in the whole process. From planning and designing, through development and testing, to deployment.<\/p><p>Besides that, every developer wants to produce high-quality and successful software, while not all of them are very fond of testing. Focusing on testing alone, which many of the testing-related books do, means losing some of the potential audience. What is worse, you lose those that would benefit from it the most.<\/p><p><i>Testing, you say. I don't have time for this. I have deadlines to meet.<\/i><\/p><p>Focusing on the end goal, producing high-quality software, instead of the journey and specific methodology, also allows us to adapt and change the process as we go, instead of sticking to some practice that is not fully applicable to a particular situation.<\/p><p>In our search for successful practices that will help us in doing our job better and faster, we tend to forget why we are using them. All those good practices don't exist in a void for their own sake: They evolved through our collective knowledge, being adapted, tweaked, and polished until they emerged under some name, to be more easily recognizable and approachable.<\/p><p>But in that effort to categorize and simplify the message we are sending to new generations of developers, we often fail to explain its origins and real purpose, passing only half of the knowledge until it degenerates into something that causes more harm than good. And then old practices are quickly abandoned without realizing the reasons for their failure, and new practices emerge, only to fail soon enough.<\/p><p>This is another reason for choosing the title Quality-Driven Development: it can be whatever you need it to be. It is a timeless reminder of your goals, insisting on practical know-how, instead of following and sticking with very specific, rigidly formed processes. And while you will still need to use at least some of those established practices to achieve your goals, you can more freely adapt them to serve you, rather than the other way around.<\/p><p>Larger companies and teams are more likely to use automated testing and other processes that contribute to software quality. Small teams and single developers, not so much. The need to ship a product on time, combined with a lack of resources to follow all the necessary steps to produce high-quality software, is always a great incentive to cut corners. Of course, larger teams are no strangers to cutting corners either, and this book is intended for all of the above, as its goal is not only to teach how to do something and how to apply a certain process, but also why all those pesky, time-consuming tasks are actually saving time and not wasting it.&nbsp;<\/p>"}],
"tocs":[
{
"guid":"BF84AC00468A4A7983ADB3418D1042D1",
"pagename":"",
"datalevel":11,
"dataversion":1,
"lang":"en",
"text":"<p>Introduction<\/p><p>Part 1. Software Development Process<\/p><ul><li>Quality Factors<\/li><li>Software Development Cycle<\/li><li>Work Smarter, Not Harder<\/li><li>Don't Let Rules Rule<\/li><li>Use the Source, Luke!<ul><li>Version Control Systems and Terminology<\/li><li>Git, GitHub... I don't git it<\/li><\/ul><\/li><li>Working With Git<ul><li>Creating a Repository<ul><li>.gitattributes configuration file<\/li><li>.gitignore configuration file<\/li><li>Adding files and committing changes<\/li><\/ul><\/li><li>Branching and Merging<ul><li>Single branch<\/li><li>Trunk-based development (GitHub flow)<\/li><li>Git flow<\/li><li>Master-Develop-Feature<\/li><li>Merge vs Rebase<\/li><li>Resolving and avoiding merge conflicts<\/li><\/ul><\/li><\/ul><\/li><li>Issue Tracking Systems<\/li><\/ul><p>Part 2. Documentation, Planning, and Design<\/p><ul><li>Software Project Documentation<ul><li>Minimum Viable Product and Future Extensions<\/li><\/ul><\/li><li>Start, Planning, and Design<ul><li>Concept Document White Paper<\/li><li>Software Requirements Specification<\/li><li>Software Design Document<\/li><\/ul><\/li><li>Source Code and API Documentation<\/li><li>Testing Documentation<ul><li>Test Case<\/li><li>Test Case Scenario<\/li><li>Test Case Document<\/li><\/ul><\/li><\/ul><p>Part 3. Introduction to Testing<\/p><ul><li>Development and Testing<ul><li>Test Early<\/li><li>Manual Testing<\/li><li>Unit Testing<\/li><li>Integration Testing<\/li><li>System Testing<\/li><li>Acceptance Testing<\/li><\/ul><\/li><li>Introduction to Unit Testing<ul><li>Manual Testing<\/li><li>Unit Testing<\/li><li>DUnit Template Wizard<\/li><li>DUnit Test Workflow<\/li><li>Writing and Running Simple Tests<\/li><li>Extending the Test Suite<\/li><li>Testing Corner Cases<\/li><li>Testing Exceptions<\/li><li>Testing the Destruction Process<\/li><li>DUnit Validation Methods<\/li><\/ul><\/li><li>Testing with DUnitX<ul><li>DUnitX Validation Methods<\/li><li>Running DUnitX in GUI<\/li><li>DUnit vs DUnitX<\/li><li>Migrating from DUnit to DUnitX<\/li><\/ul><\/li><li>DUnit Extensions<\/li><li>TestInsight<\/li><li>Unit Testing Principles<ul><li>Test Repeatability<\/li><li>Speed<\/li><li>Code Paths and Functionality Coverage<\/li><li>Testing Implementation Details<\/li><li>Testing in Isolation<\/li><li>Single Test Case per Unit Test<\/li><li>Test Granularity<\/li><\/ul><\/li><li>Test Doubles<ul><li>Dummy Test Double<\/li><li>Fake Test Double<\/li><li>Stub Test Double<\/li><li>Spy Test Double<\/li><li>Mock Test Double<\/li><\/ul><\/li><li>Test-Driven Development TDD<ul><li>Red-Green-Refactor Steps<\/li><li>Refactoring<ul><li>Internal refactoring<\/li><li>External refactoring<\/li><\/ul><\/li><li>Speeding Up the TDD Process<\/li><li>Follow TDD or Not?<\/li><li>False Expectations<\/li><li>Think Before You Code<\/li><\/ul><\/li><\/ul><p>Part 4. Test Cases<\/p><ul><li>Test Cases<\/li><li>Testing Methodologies<ul><li>Black-Box Testing Methodologies<\/li><li>White-Box Testing Methodologies<\/li><\/ul><\/li><li>Black-Box Testing<ul><li>Equivalence Partitioning &amp; Boundary Value Analysis<\/li><li>Decision Tables<\/li><li>Cause\u2013effect Graph<\/li><li>State Transition Testing<\/li><li>Classification Trees<\/li><\/ul><\/li><li>White-Box Testing<ul><li>Static Code Analysis<\/li><li>Control Flow Graph<\/li><li>Statement Coverage<\/li><li>Branch (Decision) Coverage<\/li><li>Path Coverage<\/li><li>Basic and Multiple Condition Coverage<\/li><li>Function Coverage<\/li><li>Loop Testing<\/li><li>Data Flow Testing<\/li><\/ul><\/li><li>White-Box Metrics<ul><li>Cyclomatic Complexity Metric<\/li><li>Rapps-Weyuker Metrics<\/li><\/ul><\/li><li>Code Coverage Tools<\/li><li>Test Data &amp; Scenarios<ul><li>Valid Data or Scenario<\/li><li>Invalid Data or Scenario<\/li><li>Special-Context Values<\/li><li>Boundaries &amp; Data Around Boundaries<\/li><li>Booleans<\/li><li>Enumerated Types<\/li><li>Integer Numbers<\/li><li>Floating-Point Numbers<\/li><li>Fixed-Point Numbers<\/li><li>Date and Time<\/li><li>Pointers, Objects, and Interfaces<\/li><li>Procedural Types<\/li><li>Records<\/li><li>Arrays and Buffers<\/li><li>Characters and Strings<ul><li>Specifications<\/li><li>Choosing the best string type<\/li><li>Indexed string access<\/li><li>Character buffers allocation<\/li><\/ul><\/li><li>Collections and Sets<\/li><li>Variant Types<\/li><\/ul><\/li><\/ul><p>Part 5. Development &amp; Testing<\/p><ul><li>Writing Testable Code<\/li><li>Never Say Never: Existing Code<\/li><li>Global State<ul><li>Minimizing Usage of Global State<\/li><li>Changing Global State<\/li><li>Wrapping Global State<ul><li>Procedural Types<ul><\/ul><\/li><li>Singletons<\/li><\/ul><\/li><\/ul><\/li><li>Dependencies &amp; Decoupling<ul><li>Dependencies<ul><li>Heavyweight dependencies<ul><\/ul><\/li><li>Simple, commonly used classes<\/li><li>Dependency is an integral part of the system under test<\/li><li>Code performance and complexity<\/li><li>Unit testing performance<\/li><li>Other considerations<\/li><\/ul><\/li><li>Dependency Injection<ul><li>Constructor injection<\/li><li>Property or field injection<\/li><li>Method injection<\/li><li>Factory method<\/li><li>Abstract factory<\/li><li>Dependency injection container<\/li><li>Metaclasses<\/li><\/ul><\/li><li>Dependency Architecture<ul><li>Interfaces<\/li><li>Classes and metaclasses<\/li><li>Adapter and facade patterns<\/li><\/ul><\/li><\/ul><\/li><li>Testing Generics<\/li><li>Testing Multithreaded Code<ul><li>Extract Unrelated Functionality<ul><li>Thread and task termination<\/li><li>Communicating with GUI<\/li><\/ul><\/li><li>Waiting for Threads or Tasks<\/li><li>Testing Thread Safety<\/li><li>Anonymous Methods<\/li><\/ul><\/li><li>Integration Testing<\/li><li>Testing GUI<ul><li>Extract Testable Code<\/li><li>Add Abstraction Layers<\/li><li>Use Messaging Systems<\/li><\/ul><\/li><\/ul><p>Part 6. Integration &amp; Deployment<\/p><ul><li>Integration &amp; Deployment<\/li><li>Integration &amp; Deployment Automation<ul><li>Automation Tools<\/li><li>Build<\/li><li>Test<\/li><li>Deliver &amp; Deploy<\/li><\/ul><\/li><\/ul><p>Appendix<\/p>"}],
"keywords":[
]}