{
"id":148,
"guid":"E5C451E1560941DE9DA5073DAB405974",
"pagename":"Delphi-Multithreading-PT.html",
"datalevel":9,
"dataversion":1,
"name":"Delphi Multithreading (Edici\u00F3n en Portugu\u00E9s)",
"lang":"pt",
"pubdate":"20251017",
"isbn10":"6501752515",
"isbn13":"9786501752518",
"website":"https:\/\/www.cesarromero.com.br\/index_pt.html",
"authors":[
{
"id":97,
"guid":"8310631800254ADB9BFFED6A11A53DBB",
"pagename":"Cesar-Romero.html",
"datalevel":5,
"dataversion":1}],
"publishers":[
],
"descriptions":[
{
"guid":"030A5746176C4B54A3284E72F0471A42",
"pagename":"",
"datalevel":4,
"dataversion":1,
"lang":"pt",
"text":"<p>A interface travada durante uma opera\u00E7\u00E3o demorada \u00E9 o inimigo silencioso de qualquer aplica\u00E7\u00E3o moderna. No universo Delphi, dominar a programa\u00E7\u00E3o concorrente \u00E9 a chave para transformar aplica\u00E7\u00F5es lentas e frustrantes em sistemas fluidos, responsivos e profissionais. No entanto, o caminho do multithreading \u00E9 frequentemente visto como um campo minado de deadlocks, race conditions e complexidades que intimidam at\u00E9 os desenvolvedores mais experientes.&nbsp;<\/p><p>Este livro \u00E9 o mapa definitivo para essa jornada. Com base em 30 anos de experi\u00EAncia em arquitetura de software, Cesar Romero desmistifica a concorr\u00EAncia em Delphi, guiando o leitor desde os fundamentos da TThread cl\u00E1ssica at\u00E9 a maestria da moderna Parallel Programming Library (PPL). Escrita com uma did\u00E1tica focada no \u201Cporqu\u00EA\u201D por tr\u00E1s de cada decis\u00E3o, esta obra foi projetada para ser um curso de forma\u00E7\u00E3o completo, tanto para o programador que est\u00E1 dando seus primeiros passos em threads quanto para o arquiteto que busca otimizar a performance em cen\u00E1rios de alta demanda.&nbsp;<\/p><p>Ao longo de seus cap\u00EDtulos pr\u00E1ticos, voc\u00EA aprender\u00E1 a:&nbsp;<\/p><ul><li>Gerenciar o ciclo de vida de threads de forma segura, evitando os erros mais comuns.&nbsp;<\/li><li>Dominar as primitivas de sincroniza\u00E7\u00E3o, escolhendo a ferramenta certa para cada desafio.&nbsp;<\/li><li>Simplificar seu c\u00F3digo e aproveitar ao m\u00E1ximo os processadores multi-core com TTask, IFuture e TParallel.For.&nbsp;<\/li><li>Diagnosticar e depurar os problemas mais complexos de concorr\u00EAncia.&nbsp;<\/li><li>Aplicar as melhores pr\u00E1ticas em exemplos do mundo real, incluindo o acesso concorrente a bancos de dados e o desenvolvimento de aplica\u00E7\u00F5es mobile fluidas para Android e iOS.&nbsp;<\/li><\/ul><p>Ao final desta obra, voc\u00EA n\u00E3o ter\u00E1 apenas um repert\u00F3rio de c\u00F3digo, mas a confian\u00E7a e a vis\u00E3o arquitetural para projetar e construir aplica\u00E7\u00F5es Delphi que n\u00E3o apenas funcionam, mas que encantam o usu\u00E1rio com sua performance e responsividade.<\/p>"}],
"tocs":[
{
"guid":"E368D0A7FC9A480ABC16054A8EA50E24",
"pagename":"",
"datalevel":3,
"dataversion":1,
"lang":"en",
"text":"<p>1: Introduction to Concurrent and Asynchronous Processing<br\/><br\/>1.1: The User Interface Freeze Problem (UI Freeze)<br\/>1.2: What Are Concurrent and Asynchronous Processing?<br\/>1.3: A Brief History of Concurrency: From TThread to the PPL<br\/>1.4: The True Goals of Concurrency: Responsiveness, Scalability, and Performance<br\/>1.5: The Concept of a Thread<br\/>1.6: When NOT to Use Threads (and to Look for Alternatives)<br\/><br\/>2: Fundamentals of Threads in Delphi (Basic TThread)<br\/><br\/>2.1: Creating and Managing Simple Threads<br\/>2.2: Communicating with the Main Thread (Synchronize and Queue)<br\/>2.3: Dealing with Multiple Threads and Shared Data (Introduction to Synchronization)<br\/>2.4: Anonymous Threads (TThread.CreateAnonymousThread)<br\/><br\/>3: Thread Synchronization<br\/><br\/>3.1: TCriticalSection - A Deeper Look at Simple Mutual Exclusion<br\/>3.2: TMonitor - Synchronizing Multiple Threads with a Single Object<br\/>3.3: TMutex - Synchronization Between Processes<br\/>3.4: TSemaphore - Controlling Access to Limited Resources<br\/>3.5: TEvent - Signaling Between Threads<br\/>3.6: Optimizing Concurrent Access: The Readers-Writer Pattern<br\/>3.7: TCountdownEvent - Synchronizing the Completion of Multiple Tasks<br\/>3.8: WaitForMultipleObjects - Coordinated Waiting on Multiple Events<br\/><br\/>4: Thread Management and Cancellation<br\/><br\/>4.1: Controlled Start and Pause of Threads<br\/>4.2: Graceful Thread Cancellation (Terminate and WaitFor)<br\/>4.3: Cooperative Cancellation with TCancellationToken<br\/>4.4: Managing Execution Priority (TThread.Priority)<br\/>4.5: Exception Handling in Threads<br\/>4.6: Retry Strategies in Threads<br\/><br\/>5: Asynchronous Alternatives (PostMessage \/ SendMessage, Asynchronous I\/O)<br\/><br\/>5.1: PostMessage and SendMessage - Asynchronous and Synchronous Communication via Windows Messages<br\/>5.2: Asynchronous I\/O (Overview)<br\/>5.3: Integrating Asynchronous I\/O with Threads<br\/>5.4: Asynchronous Execution Pattern on the Main Thread: The TMainThreadDispatcher<br\/>5.5: Communication Between Threads and Platforms via System.Messaging<br\/><br\/>6: Parallel Programming Library (PPL) - Simplifying Concurrency<br\/><br\/>6.1: Introduction to the PPL - The Leap to Task-Based Programming<br\/>6.2: The Heart of the PPL: ITask for Actions and IFuture&lt;T&gt; for Results<br\/>6.3: TParallel.For - Parallelizing Loops<br\/>6.4: Task Coordination: TTask.WaitForAll, TTask.WaitForAny, and TParallel.Join<br\/>6.5: PPL Task Cancellation (ITask.Cancel and ITask.CheckCanceled)<br\/>6.6: Other PPL Features: TParallelArray<br\/><br\/>7: Advanced Topics in Threads<br\/><br\/>7.1: Creating a Custom Thread Pool<br\/>7.2: TInterlocked - Atomic Operations for Extreme Performance<br\/>7.3: Memory Management and Multithreading<br\/>7.4: Advanced PPL Management: TThreadPool and TThreadPoolStats<br\/>7.5: Conditional Synchronization: TConditionVariableCS<br\/><br\/>8: Best Practices and Debugging<br\/><br\/>8.1: Code Organization (Threads in Separate Units)<br\/>8.2: Avoiding Concurrency with threadvar (Thread-Local Storage)<br\/>8.3: Shared Data and Thread-Safe Collections: Ensuring Integrity in Multithreaded Applications<br\/>8.4: Preventing Common Problems: Deadlocks and Race Conditions<br\/>8.5: Techniques to Minimize Context Switches<br\/>8.6: Debugging Multithreaded Applications<br\/>8.7: Common Problems in Multithreaded Applications and How to Solve Them<br\/>8.8: Final Recommendations and Conclusions for Best Practices<br\/><br\/>9: Threads and Concurrency in Mobile Applications (Android and iOS)<br\/><br\/>9.1: Introduction to Concurrency in Mobile Applications<br\/>9.2: Specifics of the UI Thread on Mobile and Preventing ANRs on Android<br\/>9.3: Concurrency on iOS: Rules and Native APIs<br\/>9.4: Platform-Specific Considerations and Life Cycle Management<br\/>9.5: Evolution of Threading Features for the Mobile Platform with Delphi<br\/>9.6: Parallel REST Requests to Public APIs<br\/>9.7: Reading Images from the Photo Gallery in a PPL Task<br\/>9.8: Batch Processing for Maximum Throughput<br\/>9.9: Final Recommendations for Mobile Concurrency<br\/><br\/>10: Useful Examples with the PPL<br\/><br\/>10.1: Parallel Processing of Multiple Files in a Batch<br\/>10.2: Asynchronous Network Requests with Pagination<br\/>10.3: Intensive Data Simulations and Calculations in Parallel<br\/>10.4: Orchestrating Complex Workflows with Dependencies<br\/>10.5: Task Pipeline with a State Machine<br\/><br\/>11: Practical Database Applications with Concurrency<br\/><br\/>11.1: The Non-Negotiable Principles: The Doctrine<br\/>11.2: Essential Practical Example: TDataModule in a TThread<br\/>11.3: Performance Optimization with FireDAC Connection Pooling<br\/>11.4: An Alternative Without Threads: Asynchronous Execution (amAsync) in FireDAC<br\/>11.5: Building a Complete Concurrent Architecture with the PPL, Databases, and Design Patterns<br\/>11.6: Specific Considerations for DBExpress&nbsp;<\/p>"}],
"keywords":[
]}