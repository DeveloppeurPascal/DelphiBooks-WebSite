{
"id":148,
"guid":"E5C451E1560941DE9DA5073DAB405974",
"pagename":"Delphi-Multithreading-PT.html",
"datalevel":10,
"dataversion":1,
"name":"Delphi Multithreading (Edi\u00E7\u00E3o em Portugu\u00EAs)",
"lang":"pt",
"pubdate":"20251017",
"isbn10":"6501752515",
"isbn13":"9786501752518",
"website":"https:\/\/www.cesarromero.com.br\/index_pt.html",
"authors":[
{
"id":97,
"guid":"8310631800254ADB9BFFED6A11A53DBB",
"pagename":"Cesar-Romero.html",
"datalevel":5,
"dataversion":1}],
"publishers":[
],
"descriptions":[
{
"guid":"030A5746176C4B54A3284E72F0471A42",
"pagename":"",
"datalevel":4,
"dataversion":1,
"lang":"pt",
"text":"<p>A interface travada durante uma opera\u00E7\u00E3o demorada \u00E9 o inimigo silencioso de qualquer aplica\u00E7\u00E3o moderna. No universo Delphi, dominar a programa\u00E7\u00E3o concorrente \u00E9 a chave para transformar aplica\u00E7\u00F5es lentas e frustrantes em sistemas fluidos, responsivos e profissionais. No entanto, o caminho do multithreading \u00E9 frequentemente visto como um campo minado de deadlocks, race conditions e complexidades que intimidam at\u00E9 os desenvolvedores mais experientes.&nbsp;<\/p><p>Este livro \u00E9 o mapa definitivo para essa jornada. Com base em 30 anos de experi\u00EAncia em arquitetura de software, Cesar Romero desmistifica a concorr\u00EAncia em Delphi, guiando o leitor desde os fundamentos da TThread cl\u00E1ssica at\u00E9 a maestria da moderna Parallel Programming Library (PPL). Escrita com uma did\u00E1tica focada no \u201Cporqu\u00EA\u201D por tr\u00E1s de cada decis\u00E3o, esta obra foi projetada para ser um curso de forma\u00E7\u00E3o completo, tanto para o programador que est\u00E1 dando seus primeiros passos em threads quanto para o arquiteto que busca otimizar a performance em cen\u00E1rios de alta demanda.&nbsp;<\/p><p>Ao longo de seus cap\u00EDtulos pr\u00E1ticos, voc\u00EA aprender\u00E1 a:&nbsp;<\/p><ul><li>Gerenciar o ciclo de vida de threads de forma segura, evitando os erros mais comuns.&nbsp;<\/li><li>Dominar as primitivas de sincroniza\u00E7\u00E3o, escolhendo a ferramenta certa para cada desafio.&nbsp;<\/li><li>Simplificar seu c\u00F3digo e aproveitar ao m\u00E1ximo os processadores multi-core com TTask, IFuture e TParallel.For.&nbsp;<\/li><li>Diagnosticar e depurar os problemas mais complexos de concorr\u00EAncia.&nbsp;<\/li><li>Aplicar as melhores pr\u00E1ticas em exemplos do mundo real, incluindo o acesso concorrente a bancos de dados e o desenvolvimento de aplica\u00E7\u00F5es mobile fluidas para Android e iOS.&nbsp;<\/li><\/ul><p>Ao final desta obra, voc\u00EA n\u00E3o ter\u00E1 apenas um repert\u00F3rio de c\u00F3digo, mas a confian\u00E7a e a vis\u00E3o arquitetural para projetar e construir aplica\u00E7\u00F5es Delphi que n\u00E3o apenas funcionam, mas que encantam o usu\u00E1rio com sua performance e responsividade.<\/p>"}],
"tocs":[
{
"guid":"E368D0A7FC9A480ABC16054A8EA50E24",
"pagename":"",
"datalevel":5,
"dataversion":1,
"lang":"pt",
"text":"<p>1: Introdu\u00E7\u00E3o ao Processamento Concorrente e Ass\u00EDncrono<br\/><br\/>1.1: O Problema do Congelamento da Interface (UI Freeze)<br\/>1.2: O que \u00E9 Processamento Concorrente e Ass\u00EDncrono?<br\/>1.3: Uma Breve Hist\u00F3ria da Concorr\u00EAncia: Da TThread \u00E0 PPL<br\/>1.4: Os Verdadeiros Objetivos da Concorr\u00EAncia: Responsividade, Escalabilidade e Performance<br\/>1.5: O Conceito de Thread<br\/>1.6: Quando N\u00C3O usar Threads (e buscar alternativas)<br\/><br\/>2: Fundamentos de Threads em Delphi (TThread b\u00E1sico)<br\/><br\/>2.1: Criando e Gerenciando Threads Simples<br\/>2.2: Comunicando com a Thread Principal (Synchronize e Queue)<br\/>2.3: Lidando com M\u00FAltiplas Threads e Dados Compartilhados (Introdu\u00E7\u00E3o \u00E0 Sincroniza\u00E7\u00E3o)<br\/>2.4: Threads An\u00F4nimas (TThread.CreateAnonymousThread)<br\/><br\/>3: Sincroniza\u00E7\u00E3o de Threads<br\/><br\/>3.1: TCriticalSection - Aprofundando na Exclus\u00E3o M\u00FAtua Simples<br\/>3.2: TMonitor - Sincroniza\u00E7\u00E3o de M\u00FAltiplas Threads com um \u00DAnico Objeto<br\/>3.3: TMutex - Sincroniza\u00E7\u00E3o entre Processos<br\/>3.4: TSemaphore - Controle de Acesso a Recursos Limitados<br\/>3.5: TEvent - Sinaliza\u00E7\u00E3o entre Threads<br\/>3.6: Otimizando Acesso Concorrente: O Padr\u00E3o Leitores-Escritores<br\/>3.7: TCountdownEvent - Sincronizando a Conclus\u00E3o de M\u00FAltiplas Tarefas<br\/>3.8: WaitForMultipleObjects - Espera Coordenada em M\u00FAltiplos Eventos<br\/><br\/>4: Gerenciamento e Cancelamento de Threads<br\/><br\/>4.1: In\u00EDcio e Pausa Controlada de Threads<br\/>4.2: Cancelamento Gentil de Threads (Terminate e WaitFor)<br\/>4.3: Cancelamento Cooperativo com TCancellationToken<br\/>4.4: Gerenciando a Prioridade de Execu\u00E7\u00E3o (TThread.Priority)<br\/>4.5: Tratamento de Exce\u00E7\u00F5es em Threads<br\/>4.6: Estrat\u00E9gias de Reprocessamento e Retry em Threads<br\/><br\/>5: Alternativas Ass\u00EDncronas (PostMessage \/ SendMessage, I\/O Ass\u00EDncrono)<br\/><br\/>5.1: PostMessage e SendMessage - Comunica\u00E7\u00E3o Ass\u00EDncrona e S\u00EDncrona via Mensagens Windows<br\/>5.2: I\/O Ass\u00EDncrono (Vis\u00E3o Geral)<br\/>5.3: Integra\u00E7\u00E3o de I\/O Ass\u00EDncrono com Threads<br\/>5.4: Padr\u00E3o de Execu\u00E7\u00E3o Ass\u00EDncrona na Main Thread: O TMainThreadDispatcher<br\/>5.5: Comunica\u00E7\u00E3o entre Threads e Plataformas via System.Messaging<br\/><br\/>6: Parallel Programming Library (PPL) - Simplificando a Concorr\u00EAncia<br\/><br\/>6.1: Introdu\u00E7\u00E3o \u00E0 PPL - O Salto para a Programa\u00E7\u00E3o Baseada em Tarefas<br\/>6.2: O Cora\u00E7\u00E3o da PPL: ITask para A\u00E7\u00F5es e IFuture&lt;T&gt; para Resultados<br\/>6.3: TParallel.For - Paralelizando Loops<br\/>6.4: Coordena\u00E7\u00E3o de Tarefas: TTask.WaitForAll, TTask.WaitForAny e TParallel.Join<br\/>6.5: Cancelamento de Tarefas PPL (ITask.Cancel e ITask.CheckCanceled)<br\/>6.6: Outros Recursos da PPL: TParallelArray<br\/><br\/>7: T\u00F3picos Avan\u00E7ados em Threads<br\/><br\/>7.1: Criando um Thread Pool Personalizado<br\/>7.2: TInterlocked - Opera\u00E7\u00F5es At\u00F4micas para Performance Extrema<br\/>7.3: Gerenciamento de Mem\u00F3ria e Multithreading<br\/>7.4: Gerenciamento Avan\u00E7ado da PPL: TThreadPool e TThreadPoolStats<br\/>7.5: Sincroniza\u00E7\u00E3o Condicional: TConditionVariableCS<br\/><br\/>8: Melhores Pr\u00E1ticas e Depura\u00E7\u00E3o<br\/><br\/>8.1: Organiza\u00E7\u00E3o do C\u00F3digo (Threads em Units Separadas)<br\/>8.2: Evitando Concorr\u00EAncia com threadvar (Thread-Local Storage)<br\/>8.3: Dados Compartilhados e Cole\u00E7\u00F5es Thread-Safe: Garantindo a Integridade em Aplica\u00E7\u00F5es Multithreaded<br\/>8.4: Preven\u00E7\u00E3o de Problemas Comuns: Deadlocks e Race Conditions<br\/>8.5: T\u00E9cnicas para Minimizar Trocas de Contexto (Context Switches)<br\/>8.6: Depura\u00E7\u00E3o de Aplica\u00E7\u00F5es Multithreaded<br\/>8.7: Problemas Comuns em Aplica\u00E7\u00F5es Multithreaded e Como Resolv\u00EA-los<br\/>8.8: Recomenda\u00E7\u00F5es Finais e Conclus\u00F5es para Melhores Pr\u00E1ticas<br\/><br\/>9: Threads e Concorr\u00EAncia em Aplica\u00E7\u00F5es Mobile (Android e iOS)<br\/><br\/>9.1: Introdu\u00E7\u00E3o \u00E0 Concorr\u00EAncia em Aplica\u00E7\u00F5es Mobile<br\/>9.2: Particularidades da Thread da UI em Mobile e Preven\u00E7\u00E3o de ANRs no Android<br\/>9.3: Concorr\u00EAncia no iOS: Regras e APIs Nativas<br\/>9.4: Cuidados Espec\u00EDficos de Cada Plataforma e Gest\u00E3o de Ciclo de Vida<br\/>9.5: Evolu\u00E7\u00E3o dos Recursos para Threads na Plataforma Mobile com Delphi<br\/>9.6: Requisi\u00E7\u00F5es REST Paralelas para APIs P\u00FAblicas<br\/>9.7: Lendo Imagens da Galeria de Fotos em uma Tarefa PPL<br\/>9.8: Processamento em Lote para M\u00E1xima Velocidade (Throughput)<br\/>9.9: Recomenda\u00E7\u00F5es Finais para Concorr\u00EAncia Mobile<br\/><br\/>10: Exemplos \u00DAteis com PPL<br\/><br\/>10.1: Processamento Paralelo de M\u00FAltiplos Arquivos em Lote<br\/>10.2: Requisi\u00E7\u00F5es de Rede Ass\u00EDncronas com Pagina\u00E7\u00E3o<br\/>10.3: Simula\u00E7\u00F5es e C\u00E1lculos Intensivos de Dados em Paralelo<br\/>10.4: Orquestra\u00E7\u00E3o de Fluxos de Trabalho Complexos com Depend\u00EAncias<br\/>10.5: Pipeline de Tarefas com M\u00E1quina de Estado<br\/><br\/>11: Aplica\u00E7\u00F5es Pr\u00E1ticas de Banco de Dados com Concorr\u00EAncia<br\/><br\/>11.1: Os Princ\u00EDpios Inegoci\u00E1veis: A Doutrina<br\/>11.2: Exemplo Pr\u00E1tico Essencial: TDataModule em uma TThread<br\/>11.3: Otimiza\u00E7\u00E3o de Performance com Connection Pooling do FireDAC<br\/>11.4: Alternativa Sem Threads: Execu\u00E7\u00E3o Ass\u00EDncrona (amAsync) do FireDAC<br\/>11.5: Construindo uma Arquitetura Concorrente Completa com PPL, Banco de Dados e Padr\u00F5es de Design<br\/>11.6: Considera\u00E7\u00F5es Espec\u00EDficas para DBExpress&nbsp;<\/p>"}],
"keywords":[
]}